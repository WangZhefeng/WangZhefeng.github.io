---
title: 数据库操作优化
author: 王哲峰
date: '2022-05-06'
slug: database-sql-optim
categories:
  - database
tags:
  - sql
  - tool
---

<style>
details {
    border: 1px solid #aaa;
    border-radius: 4px;
    padding: .5em .5em 0;
}

summary {
    font-weight: bold;
    margin: -.5em -.5em 0;
    padding: .5em;
}

details[open] {
    padding: .5em;
}

details[open] summary {
    border-bottom: 1px solid #aaa;
    margin-bottom: .5em;
}
</style>

<details><summary>目录</summary><p>

- [内容](#内容)
- [调优](#调优)
- [WHERE 语句](#where-语句)
- [JOIN](#join)
- [字段类型](#字段类型)
- [索引使用](#索引使用)
- [游标使用](#游标使用)
- [临时表使用](#临时表使用)
- [表变量使用](#表变量使用)
- [存储过程](#存储过程)
- [事务隔离级别](#事务隔离级别)
</p></details><p></p>

# 内容

1. 开发规范
1. 数据库引擎优化
2. 表结构优化
   - 索引
   - 游标
   - 临时表
3. SQL语句优化

# 调优

1. 规范上，只要有查询需求，都应该建索引
    -  理论上来收，如果表有一定的数据量，那就应该要创建对应的索引
2. 覆盖索引
    - 使用覆盖索引，减少回表所消耗的时间。意味着在 `select` 的时候，一定要指明对应的列，而不是 `select *`
3. 联合索引(最左匹配原则)
    - 考虑是否组件联合索引，如果组建联合索引，尽量将区分度最高的放在最左边，并且要考虑最左匹配原则
4. 索引列不参与计算
    - 对索引进行函数操作或者表达式计算会导致索引失效
5. 子查询优化多分页
    - 利用子查询优化超多分页场景。比如 `limit offset`，`n` 在 MySQL 是获取 `offset + n` 的记录，再
      返回 `n` 条。而利用子查询则是查出 `n` 条，通过 ID 检索对应的记录出来，提高查询效率
6. `explain` 查看执行计划
    - 通过 `explain` 命令来查看 SQL 的执行计划，看看自己写的 SQL 是否走了索引，走了什么索引。
    - 通过 `show profile` 来查看 SQL 对系统资源的损耗情况(不过一般还是比较少用到的) 
7. 事务尽量简洁高效
    - 在开启事务后，在事务内尽可能只操作数据库，并有意识地减少锁的持有时间。
      比如在事务内需要插入、修改数据，那可以先插入后修改。
      因为修改是更新操作，会加行锁。如果先更新，那并发下可能会导致多个事务的请求等待行锁释放
8. 在 `where`, `order by` 涉及的字段上建立索引
9. 索引并不是越多越好, 索引固然可以提高相应的 `select` 的效率, 
   但同时也降低了 `insert` 及 `update` 的效率, 因为 `insert` 或 `update` 时有可能会重建索引, 
   所以怎样建索引需要慎重考虑, 视具体情况而定. 一个表的索引数最好不要超过 6 个, 
   若太多则应考虑一些不常使用到的列上建的索引是否有必要
10. 用对了索引，线上查询还是慢的问题
    - 原因：
        - 如果走对了索引，但查询还是慢，一般来说是表的数据量实在是太大了
    - 处理：思路大致的就是以空间换时间，相同的数据换别的地方也存储一份，提高查询效率
        - 首先，考虑能补能把旧的数据给“删掉”，如果旧的数据已经没有查询的业务了，
          最简单的办法是“删掉”，数据量降低了，检索速度自然就快了。或者同步到 Hive，离线存储一份
        - 如果不能删掉旧数据，那就考虑在查询之前，直接走一层缓存(Redis)。而走缓存的话，
          又要看业务能不能忍受读取的非真正实时的数据(毕竟 Redis 和 MySQL 的数据一致性需要保证)，
          如果查询条件相对复杂且多变的话(涉及各种 `group by` 和 `sum`)，
          那走缓存也不是一种好的办法，维护起来就不方便了
        - 看看是不是有字符串检索的场景导致查询低效，如果是的话，
          可以考虑把表的数据导入至 Elasticsearch 类的搜索引擎，
          后续的线上查询就直接走 Elasticsearch 了。
          MySQL->Elasticsearch 需要有对应的同步程序，
          一般就是监听 MySQL 的 binlog，解析 binlog 后导入到 Elasticsearch
        - 如果还不是的话，那考虑要不要根据查询条件的维度，做相对应的聚合表，线上的请求就查询聚合表的数据，不走原表。
          比如，用户下单后，有一份订单明细，而订单明细表的量级太大。但在产品侧(前台)透出的查询功能是以天维度来展示的，
          那就可以将每个用户的每天数据聚合起来，在聚合表就是一个用户一天只有一条汇总后的数据。查询走聚合后的表，速度会快很多
11. 写数据性能瓶颈
    - 如果在 MySQL 读写都有瓶颈，那首先看下目前 MySQL 的架构是怎么样的。
      如果是单库的，那是不是可以考虑升级至主从架构，实现读写分离；
      简单理解就是：主库接收写请求，从库接收读请求。从库的数据由主库发送的 binlog 进而更新，
      实现主从数据一致(在一般场景下，主从的数据是通过异步来保证最终一致性的)
    - 如果在主从架构下，读写仍存在瓶颈，那就要考虑是否要分库分表了。通过业务进行分库分表，
      比如流量有流量数据库，广告有广告的数据库，商品有商品的数据库。所以，分库分表的含义是：
      在原来的某个库的某个表进而拆分，将数据量打散至多库和多表
12. 如何进行分库分表
    - 以什么作为分库键？一般来说是按照 Id 的，如果要按照其他的维度进行查询，那还是参照上面的的思路(以空间换时间)
    - 分库分表后的 ID 如何生成
        - 这就涉及到分布式 ID 生成的方式了，思路有很多。有借助 MySQL 自增的，有借助 Redis 自增的，
          有基于雪花算法自增的。具体使用哪种方式，那就看公司的技术栈了，
          一般使用 Redis 和基于雪花算法实现用得比较多。
          至于为什么强调自增(还是跟索引是有序有关)
13. 分库分表时的数据迁移过程
    - 一般采取「双写」的方式来进行迁移，大致步骤就是：
    - 一、增量的消息各自往新表和旧表写一份
    - 二、将旧表的数据迁移至新库
    - 三、迟早新表的数据都会追得上旧表(在某个节点上数据是同步的)
    - 四、校验新表和老表的数据是否正常(主要看能不能对得上)
    - 五、开启双读(一部分流量走新表，一部分流量走老表)，相当于灰度上线的过程
    - 六、读流量全部切新表，停止老表的写入
    - 七、提前准备回滚机制，临时切换失败能恢复正常业务以及有修数据的相关程序
14. 定长字段中 NULL 也占空间

# WHERE 语句

1. 尽量避免全表扫描
    - 措施: 用 `where` 语句进行筛选
2. 尽量避免在 `where` 子句中对字段进行 `is null` 判断
    - 后果: 将导致引擎放弃使用索引而进行全表扫描; 
    - 措施: 最好不要给数据库留NULL, 尽可能使用NOT NULL填充数据库; 
3. 尽量避免在 `where` 子句中使用 `!=` 操作符
    - 后果: 将导致引擎放弃使用索引而进行全表扫描; 
4. 尽量避免在 `where` 子句中使用 `or` 连接条件
    - 后果: 如果一个字段有索引, 一个字段没有索引, 将导致引擎放弃使用索引而进行全表扫描; 
    - 措施: 使用 `union all`
5. 尽量避免在 `where` 子句中使用 `in` 和 `not in`
    - 后果: 将导致引擎放弃使用索引而进行全表扫描; 
    - 措施: 
        - 连续值使用 `>, <, >=, <=` 或者 `between` ; 
        - 用 `exists` 代替 `in` , 或用 `not exists` 代替 `not in` ; 
6. 尽量避免在 `where` 子句中使用参数
    - 后果: 全表扫描; 
    - 措施: 强制查询使用索引;  `select * from t with(index(索引名)) where num = @num` ; 
7. 尽量避免在 `where` 子句中 `=` 左边对字段进行函数、算数运算、或其他表达式操作
    - 后果: 将导致引擎放弃使用索引而进行全表扫描; 
    - 措施: 对表达式进行转换;  `where num / 2 = 100` => `where num = 100 * 2` ; 
8. 尽量避免在 `where` 子句中对字段进行函数操作
    - 后果: 将导致引擎放弃使用索引而进行全表扫描; 
    - 措施: 使用其他筛选条件

# JOIN

1. 对多张表进行 `join` 操作, 要先分页再join

# 字段类型

1. 尽可能的使用 varchar/nvarchar 代替 char/nchar, 因为首先变长字段存储空间小, 
   可以节省存储空间, 其次对于查询来说, 在一个相对较小的字段内搜索效率显然要高些
2. 尽量使用数字型字段, 若只含数值信息的字段尽量不要设计为字符型, 这会降低查询和连接的性能, 
   并会增加存储开销. 这是因为引擎在处理查询和连
   接时会逐个比较字符串中每一个字符, 而对于数字型而言只需要比较一次就够了

# 索引使用

1. 在使用索引字段作为条件时, 如果该索引是复合索引, 
    那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引, 
    否则该索引将不会被使用, 并且应尽可能的让字段顺序与索引顺序相一致
2. 应尽可能的避免更新 clustered 索引数据列, 因为 clustered 索引数据列的顺序就是表记录的物理存储顺序, 
    一旦该列值改变将导致整个表记录的顺序的调整, 会耗费相当大的资源. 若应用系统需要频繁更新 clustered 索引数据列, 
    那么需要考虑是否应将该索引建为 clustered 索引

# 游标使用

1. 尽量避免使用游标, 因为游标的效率较差

# 临时表使用

1. 如果使用到了临时表, 在存储过程的最后务必将所有的临时表显式删除, 先 truncate table, 
   然后 drop table , 这样可以避免系统表的较长时间锁定
2. 在新建临时表时, 如果一次性插入数据量很大, 那么可以使用 select into
   代替 create table, 避免造成大量 log, 以提高速度; 如果数据量不大, 
   为了缓和系统表的资源, 应先 create table, 然后 insert
3. 避免频繁创建和删除临时表, 以减少系统表资源的消耗. 临时表并不是不可使用, 
   适当地使用它们可以使某些例程更有效, 例如, 当需要重复引用大型表或常用表中的某个数据集时. 
   但是, 对于一次性事件, 最好使用导出表

# 表变量使用

# 存储过程

# 事务隔离级别

MySQL 默认隔离级别是 `Repeatable read`(可重复读)，有可能因为间隙锁导致的死锁问题，
是由于历史原因导致(binlog 主从一致性，binlog 记录了数据库表结构和表数据变更)。
互联网公司一般的隔离级别是 `read commited`(读已提交)，

选用什么隔离级别主要看应用场景，因为隔离级别越低，事务并发性能越高
