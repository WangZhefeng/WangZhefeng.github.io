---
title: 第七章、迭代器与生成器
author: 王哲峰
date: '2020-05-01'
slug: js-iterator-generator
categories:
  - 前端
tags:
  - tool
output:
  blogdown::html_page:
    toc: true
    fig_width: 6
    dev: "svg"
---

<script src="{{< blogdown/postref >}}index_files/header-attrs/header-attrs.js"></script>

<div id="TOC">
<ul>
<li><a href="#迭代器模式">1.迭代器模式</a>
<ul>
<li><a href="#可迭代协议">1.1 可迭代协议</a></li>
<li><a href="#迭代器协议">1.2 迭代器协议</a></li>
<li><a href="#自定义迭代器">1.3 自定义迭代器</a></li>
<li><a href="#提前终止迭代器">1.4 提前终止迭代器</a></li>
</ul></li>
<li><a href="#生成器">2.生成器</a>
<ul>
<li><a href="#生成器基础">2.1 生成器基础</a></li>
<li><a href="#通过-yield-中断执行">2.2 通过 yield 中断执行</a></li>
<li><a href="#生成器作为默认迭代器">2.3 生成器作为默认迭代器</a></li>
<li><a href="#提前终止生成器">2.4 提前终止生成器</a></li>
</ul></li>
</ul>
</div>

<ul>
<li><p>循环是迭代机制的基础，这是因为它可以指定迭代的次数，以及每次迭代要执行什么操作。每次循环都会在下一次迭代开始之前完成，而每次迭代的顺序都是事先定义好的</p></li>
<li><p>迭代会在一个有序集合上进行，数组是 JavaScript 中有序集合的最典型例子</p>
<ul>
<li>因为数组有已知的长度，且数组每一项都可以通过索引获取，所以整个数组可以通过递增索引来遍历</li>
</ul>
<pre class="js"><code>let collection = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];
for (let index = 0; index &lt; collection.length; ++index) {
    console.log(collection[index]);
}</code></pre></li>
<li><p>由于如下原因，通过循环来执行例程并不理想：</p>
<ul>
<li>迭代之前需要事先知道如何使用数据结构
<ul>
<li>数组中的每一项都只能先通过引用取得数组对象，然后再通过 <code>[]</code> 操作符取得特定索引位置上的项。这种情况并不适用于所有数据结构</li>
</ul></li>
<li>遍历顺序并不是数据结构固有的
<ul>
<li>通过递增索引来访问数据是特定与数组类型的方式，并不适用于其他具有隐式顺序的数据结构</li>
</ul></li>
</ul></li>
<li><p>ES5 新增了 <code>Array.prototype.forEach()</code> 方法，向通用迭代需求迈进了一步，但仍然不够理想</p>
<ul>
<li>这个方法解决了单独记录索引和通过数组对象取得值的问题，不过，没有办法表示迭代何时终止。因为这个方法只适用于数组，而且回调结构也比较笨拙</li>
</ul>
<pre class="js"><code>let collection = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];
collection.forEach(item) =&gt; console.log(item);
// foo
// bar
// baz</code></pre></li>
</ul>
<div id="迭代器模式" class="section level2">
<h2>1.迭代器模式</h2>
<ul>
<li><p>迭代器模式描述了一个方案，即可以把有些结构称为 <strong>可迭代对象(iterable)</strong>，因为它们实现了正式的 <code>Iterable</code> 接口，而且可以通过迭代器 <code>Iterator</code> 消费</p>
<ul>
<li>可迭代对象
<ul>
<li>可迭代对象是一种抽象的说法。基本上，可以把可迭代对象理解成数组或集合这样的集合类型的对象，它们包含的元素是有限的，而且都具有无歧义的遍历顺序</li>
<li>可迭代对象不一定是集合对象，也可以是仅仅具有类似数组行为的其他数据结构</li>
<li>临时性可迭代对象可以实现为生成器</li>
</ul></li>
</ul>
<pre class="js"><code>// 数组的元素是有限的
// 递增索引可以访问每个元素
let arr = [3, 1, 4];

// 集合的元素是有限的
// 可以按插入的顺序访问每个元素
let set = new Set().add(3).add(1).add(4);</code></pre>
<ul>
<li><code>Iterable</code> 接口
<ul>
<li>任何实现<code>Iterable</code> 接口的数据结构都可以被实现 <code>Iterator</code> 接口的结构消费(consume)</li>
</ul></li>
<li><code>Iterator</code> 迭代器
<ul>
<li>按需创建的一次性对象</li>
<li>每个迭代器都会关联一个可迭代对象，而迭代器会暴露迭代其关联可迭代对象的 AP</li>
<li>迭代器无需了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值</li>
</ul></li>
</ul></li>
</ul>
<div id="可迭代协议" class="section level3">
<h3>1.1 可迭代协议</h3>
</div>
<div id="迭代器协议" class="section level3">
<h3>1.2 迭代器协议</h3>
</div>
<div id="自定义迭代器" class="section level3">
<h3>1.3 自定义迭代器</h3>
</div>
<div id="提前终止迭代器" class="section level3">
<h3>1.4 提前终止迭代器</h3>
</div>
</div>
<div id="生成器" class="section level2">
<h2>2.生成器</h2>
<div id="生成器基础" class="section level3">
<h3>2.1 生成器基础</h3>
</div>
<div id="通过-yield-中断执行" class="section level3">
<h3>2.2 通过 yield 中断执行</h3>
</div>
<div id="生成器作为默认迭代器" class="section level3">
<h3>2.3 生成器作为默认迭代器</h3>
</div>
<div id="提前终止生成器" class="section level3">
<h3>2.4 提前终止生成器</h3>
</div>
</div>
