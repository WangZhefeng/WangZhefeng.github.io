---
title: 第三章、语言基础
author: 王哲峰
date: '2020-01-01'
slug: js-basic
categories:
  - 前端
tags:
  - tool
output:
  blogdown::html_page:
    toc: true
    fig_width: 6
    dev: "svg"
---

<script src="{{< blogdown/postref >}}index_files/header-attrs/header-attrs.js"></script>

<div id="TOC">
<ul>
<li><a href="#一语法">一、语法</a>
<ul>
<li><a href="#区分大小写">1.区分大小写</a></li>
<li><a href="#标识符">2.标识符</a></li>
<li><a href="#注释">3.注释</a></li>
<li><a href="#严格模式">4.严格模式</a></li>
<li><a href="#语句">5.语句</a></li>
</ul></li>
<li><a href="#二关键字与保留字">二、关键字与保留字</a>
<ul>
<li><a href="#ecma-262-第-5-版">1.ECMA-262 第 5 版</a></li>
<li><a href="#ecma-262-第6版">2.ECMA-262 第6版</a></li>
<li><a href="#严格模式下保留">3.严格模式下保留</a></li>
<li><a href="#模块代码中保留">4.模块代码中保留</a></li>
</ul></li>
<li><a href="#三变量">三、变量</a>
<ul>
<li><a href="#var-声明">1.var 声明</a>
<ul>
<li><a href="#var-定义变量">1.1 var 定义变量</a></li>
<li><a href="#var-声明作用域">1.2 var 声明作用域</a></li>
<li><a href="#var-声明提升">1.3 var 声明提升</a></li>
</ul></li>
<li><a href="#let-声明">2.let 声明</a>
<ul>
<li><a href="#let-声明变量">2.1 let 声明变量</a></li>
<li><a href="#暂时性死区">2.2 暂时性死区</a></li>
<li><a href="#全局声明">2.3 全局声明</a></li>
<li><a href="#条件声明">2.4 条件声明</a></li>
<li><a href="#for-循环中的-let-声明">2.5 for 循环中的 let 声明</a></li>
</ul></li>
<li><a href="#const-声明">3.const 声明</a>
<ul>
<li><a href="#const-声明变量">3.1 const 声明变量</a></li>
<li><a href="#声明风格及最佳实践">3.2 声明风格及最佳实践</a></li>
</ul></li>
</ul></li>
<li><a href="#四数据类型">四、数据类型</a>
<ul>
<li><a href="#typeof-操作符">1.typeof 操作符</a></li>
<li><a href="#undefined">2.Undefined</a></li>
<li><a href="#null">3.Null</a></li>
<li><a href="#boolean">4.Boolean</a></li>
<li><a href="#number">5.Number</a></li>
<li><a href="#string">6.String</a></li>
<li><a href="#symbol">7.Symbol</a>
<ul>
<li><a href="#符号的基本用法">7.1 符号的基本用法</a></li>
<li><a href="#使用全局符号注册表">7.2 使用全局符号注册表</a></li>
<li><a href="#使用符号作为属性">7.3 使用符号作为属性</a></li>
<li><a href="#常用内置符号">7.4 常用内置符号</a></li>
<li><a href="#symbol.asynciterator">7.5 Symbol.asyncIterator</a></li>
</ul></li>
<li><a href="#object">8.Object</a></li>
</ul></li>
<li><a href="#五操作符">五、操作符</a>
<ul>
<li><a href="#一元操作符">1.一元操作符</a></li>
<li><a href="#位操作符">2.位操作符</a></li>
<li><a href="#布尔操作符">3.布尔操作符</a></li>
<li><a href="#乘性操作符">4.乘性操作符</a></li>
<li><a href="#指数操作符">5.指数操作符</a></li>
<li><a href="#加性操作符">6.加性操作符</a></li>
<li><a href="#关系操作符">7.关系操作符</a></li>
<li><a href="#相等操作符">8.相等操作符</a>
<ul>
<li><a href="#等于和不等于">8.1 等于和不等于</a></li>
<li><a href="#全等和不全等">8.2 全等和不全等</a></li>
</ul></li>
<li><a href="#条件操作符">9.条件操作符</a></li>
<li><a href="#赋值操作符">10.赋值操作符</a></li>
<li><a href="#逗号操作符">11. 逗号操作符</a></li>
</ul></li>
<li><a href="#六语句">六、语句</a>
<ul>
<li><a href="#if">1.if</a></li>
<li><a href="#do-while">2.do-while</a></li>
<li><a href="#while">3.while</a></li>
<li><a href="#for">4.for</a></li>
<li><a href="#for-in">5.for-in</a></li>
<li><a href="#for-of">6.for-of</a></li>
<li><a href="#label">7.label</a></li>
<li><a href="#break">8.break</a></li>
<li><a href="#continue">9.continue</a></li>
<li><a href="#with">10.with</a></li>
<li><a href="#switch">11.switch</a></li>
</ul></li>
<li><a href="#七函数">七、函数</a>
<ul>
<li><a href="#函数基本知识">1.函数基本知识</a></li>
<li><a href="#函数对象">2.函数对象</a></li>
<li><a href="#箭头函数">3.箭头函数</a></li>
<li><a href="#函数名">4.函数名</a></li>
</ul></li>
</ul>
</div>

<div id="一语法" class="section level1">
<h1>一、语法</h1>
<div id="区分大小写" class="section level2">
<h2>1.区分大小写</h2>
<ul>
<li>JavaScript 区分大小写</li>
</ul>
</div>
<div id="标识符" class="section level2">
<h2>2.标识符</h2>
<ul>
<li>标识符包含: 变量、函数、属性、函数参数</li>
<li>字母、下划线、美元符号开头</li>
<li>字母、下划线、美元符号、数字组成</li>
<li>惯例: 驼峰大小写, 第一个单词的首字母小写, 后面每个单词的首字母大写</li>
</ul>
</div>
<div id="注释" class="section level2">
<h2>3.注释</h2>
<ul>
<li>单行: <code>// 单行注释</code></li>
<li>多行: <code>/* 多行注释 */</code></li>
</ul>
</div>
<div id="严格模式" class="section level2">
<h2>4.严格模式</h2>
<ul>
<li>严格模式是一种不同的 JavaScript 解析和执行模型, ECMAScript 3 的一些不规范写法在这种模式下会被处理, 对于不安全的活动将抛出错误。选择这种语法形式的目的是不破坏 ECMAScript 3 语法</li>
<li>要对整个脚本启用严格模式, 在脚本的开头加上 <code>"use strict";</code></li>
<li>所有现代浏览器都支持严格模式</li>
</ul>
</div>
<div id="语句" class="section level2">
<h2>5.语句</h2>
<ul>
<li>语句以分号结尾, 不是必须的, 建议加</li>
<li>多条语句可以合并到一个 C 语言风格的代码块中。代码块由 <code>{}</code> 包含。控制流语句在执行多条语句时要求必须有代码块, 最佳实践是始终在控制语句中使用代码块</li>
</ul>
</div>
</div>
<div id="二关键字与保留字" class="section level1">
<h1>二、关键字与保留字</h1>
<div id="ecma-262-第-5-版" class="section level2">
<h2>1.ECMA-262 第 5 版</h2>
<ul>
<li>break</li>
<li>do</li>
<li>in</li>
<li>typeof</li>
<li>case</li>
<li>else</li>
<li>instanceof</li>
<li>var</li>
<li>catch</li>
<li>export</li>
<li>new</li>
<li>void</li>
<li>class</li>
<li>extends</li>
<li>return</li>
<li>while</li>
<li>const</li>
<li>finally</li>
<li>super</li>
<li>with</li>
<li>continue</li>
<li>for</li>
<li>switch</li>
<li>yield</li>
<li>debugger</li>
<li>function</li>
<li>this</li>
<li>default</li>
<li>if</li>
<li>throw</li>
<li>delete</li>
<li>import</li>
<li>try</li>
</ul>
</div>
<div id="ecma-262-第6版" class="section level2">
<h2>2.ECMA-262 第6版</h2>
<ul>
<li>enum</li>
</ul>
</div>
<div id="严格模式下保留" class="section level2">
<h2>3.严格模式下保留</h2>
<ul>
<li>implements</li>
<li>package</li>
<li>pubilc</li>
<li>interface</li>
<li>protected</li>
<li>static</li>
<li>let</li>
<li>private</li>
</ul>
</div>
<div id="模块代码中保留" class="section level2">
<h2>4.模块代码中保留</h2>
<ul>
<li>await</li>
</ul>
</div>
</div>
<div id="三变量" class="section level1">
<h1>三、变量</h1>
<div id="var-声明" class="section level2">
<h2>1.var 声明</h2>
<div id="var-定义变量" class="section level3">
<h3>1.1 var 定义变量</h3>
<ul>
<li>定义不初始化</li>
</ul>
<pre class="js"><code>var message; // undefined</code></pre>
<ul>
<li><p>定义并初始化</p>
<ul>
<li>只是一个简单的赋值, 可以改变保存的值, 也可以改变值的类型</li>
</ul></li>
</ul>
<pre class="js"><code>var message = &quot;hi&quot;
message = 100; // 合法, 但不推荐</code></pre>
<ul>
<li>重复声明</li>
</ul>
<pre class="js"><code>var name = &quot;Matt&quot;;
var name = &quot;John&quot;;
console.log(name); // &quot;John&quot;</code></pre>
</div>
<div id="var-声明作用域" class="section level3">
<h3>1.2 var 声明作用域</h3>
<ul>
<li>使用 var 操作符定义的变量会成为包含它的函数的局部变量</li>
</ul>
<pre class="js"><code>function test() {
    var message = &quot;hi&quot;; // 局部变量
}
test();
console.log(message); // 出错</code></pre>
<ul>
<li>在函数内部定义变量时省略 var 操作符可以创建一个全局变量</li>
</ul>
<pre class="js"><code>function test() {
    message = &quot;hi&quot;; // 全局变量
}
test();
console.log(message); // &quot;hi&quot;</code></pre>
<ul>
<li>定义多个变量</li>
</ul>
<pre class="js"><code>var message = &quot;hi&quot;, found = false, age = 29;</code></pre>
<ul>
<li>在严格模式下, 不能定义名为 eval 和 arguments 的变量, 否则会导致语法错误</li>
</ul>
</div>
<div id="var-声明提升" class="section level3">
<h3>1.3 var 声明提升</h3>
<ul>
<li>使用 var 关键字声明的变量会自动提升(hoist)到函数作用域顶部</li>
</ul>
<pre class="js"><code>function foo() {
    console.log(age);
    var age = 26;
}
foo(); // undefined

// 等价代码
function foo() {
    var age;
    console.log(age);
    age = 26;
}
foo(); // undefined</code></pre>
<ul>
<li>反复多次使用 var 声明统一变量也没有问题</li>
</ul>
<pre class="js"><code>function foo() {
    var age = 16;
    var age = 26;
    var age = 36;
    console.log(age);
}
foo(); // 36</code></pre>
</div>
</div>
<div id="let-声明" class="section level2">
<h2>2.let 声明</h2>
<div id="let-声明变量" class="section level3">
<h3>2.1 let 声明变量</h3>
<ul>
<li>let 跟 var 最明显的区别是: let 声明的范围是块作用域, 而 var 声明的范围是函数作用域</li>
</ul>
<pre class="js"><code>if (true) {
    var name = &quot;Matt&quot;;
    console.log(name); // Matt
}
console.log(name); // Matt</code></pre>
<pre class="js"><code>if (true) {
    let age = 26;
    console.log(age); // 26
}
console.log(age); // ReferenceError: age 没有定义</code></pre>
<ul>
<li>let 不允许同一个块作用域中出现冗余声明, 会导致报错</li>
</ul>
<pre class="js"><code>let name = &quot;Matt&quot;;
let name = &quot;John&quot;;
console.log(name); // SyntaxError: Identifier &#39;name&#39; has already been declared</code></pre>
<ul>
<li>JavaScript 引擎会记录用于变量声明的标识符及其所在的块作用域, 因此嵌套使用相同的标识符不会报错</li>
</ul>
<pre class="js"><code>var name = &quot;Nicholas&quot;;
console.log(name); // &quot;Nicholas&quot;

if (true) {
    var name = &quot;Matt&quot;;
    console.log(name); // &quot;Matt&quot;
}

let age = 30;
console.log(age); //30
if (true) {
    let age = 26;
    console.log(age); // 26
}</code></pre>
<ul>
<li>var 跟 let 声明的变量是一样的</li>
</ul>
</div>
<div id="暂时性死区" class="section level3">
<h3>2.2 暂时性死区</h3>
<ul>
<li><p>let 声明的变量不会再作用域中被提升</p>
<ul>
<li>在 let 声明之前的执行瞬间被称为”暂时性死区”(temporal dead zone),
在此阶段引用任何后面才声明的变量都会抛出 ReferenceError。</li>
</ul></li>
</ul>
<pre class="js"><code>// name 会被提升
console.log(name); // undefined
var name = &quot;Matt&quot;;

// age 不会被提升
console.log(age); // ReferenceError: age 没有定义
let age = 26;</code></pre>
</div>
<div id="全局声明" class="section level3">
<h3>2.3 全局声明</h3>
<ul>
<li>使用 let 在全局作用域中声明的变量不会成为 window 对象的属性, var 声明的变量则会</li>
</ul>
<pre class="js"><code>var name = &quot;Matt&quot;;
console.log(window.name); // &quot;Matt&quot;

let age = 26;
console.log(window.age); // undefined</code></pre>
</div>
<div id="条件声明" class="section level3">
<h3>2.4 条件声明</h3>
<ul>
<li>因为 let 的作用域是块, 所以不可能检查前面是否已经使用 let 声明过同名变量, 同时也就不可能在没有声明的情况下声明它。而 var 声明变量时, 由于声明会被提升, JavaScript 引擎会自动将多余的声明在作用域顶部合并为一个声明</li>
<li>let 声明不能依赖条件声明模式</li>
</ul>
<pre class="html"><code>&lt;script&gt;
    var name = &quot;Nicholas&quot;;
    let age = 26;
&lt;/script&gt;

&lt;script&gt;
    // 假设脚本不确定页面中是否已经声明了同名变量, 那么可以假设还没有声明过
    // 这里没有问题, 因为可以被作为一个提升声明来处理, 不需要检查之前是否声明过同名变量
    var name = &quot;Matt&quot;;
    
    // 如果 age 之前声明过, 这里会报错
    let age = 26;
&lt;/script&gt;</code></pre>
<pre class="html"><code>&lt;script&gt;
    let name = &quot;Nicholas&quot;;
    let age = 26;
&lt;/script&gt;

&lt;script&gt;
    // 假设脚本不确定页面中是否已经声明了同名变量, 那么可以假设还没有声明过
    if (typeof name === &quot;undefined&quot;) {
        let name = &quot;Matt&quot;; // name 被限制在 if {} 块作用域内
    }
    name = &quot;Matt&quot;;         // 因此这个赋值形同全局赋值
    
    try {
        console.log(age);  // 如果 age 没有声明过, 则会报错
    }
    catch(error) {
        let age;           // age 被限制在 catch {} 作用域内
    }
    age = 26;          // 因此这个赋值形同全局赋值
&lt;/script&gt;</code></pre>
</div>
<div id="for-循环中的-let-声明" class="section level3">
<h3>2.5 for 循环中的 let 声明</h3>
<ul>
<li>在 let 出现之前, for 循环定义的迭代变量会渗透到循环体外部; 使用 let 之后, for 循环定义的迭代变量不会渗透到循环体外部</li>
</ul>
<pre class="js"><code>for (var i = 0; i &lt; 5; ++i) {
    console.log(&quot;hello world!&quot;);
}
console.log(i); // 5

for (let i = 0; i &lt; 5; ++i) {
    console.log(&quot;hello world!&quot;);
}
console.log(i); // ReferenceError: i 没有定义</code></pre>
<ul>
<li>使用 var 的时候, 在退出循环的时, 迭代变量保存的是导致循环退出的值, 之后执行超时逻辑时, 所有的迭代变量都是同一个变量; 而使用 let 声明迭代变量时, JavaScript 引擎在后台为每个循环声明一个新的迭代变量</li>
</ul>
<pre class="js"><code>for (var i = 0; i &lt; 5, ++i) {
    setTimeout(() =&gt; console.log(i), 0) // 5 5 5 5 5
}

for (let i = 0; i &lt; 5; ++i) {
    setTimeout(() =&gt; console.log(i), 0) // 0 1 2 3 4
}</code></pre>
</div>
</div>
<div id="const-声明" class="section level2">
<h2>3.const 声明</h2>
<div id="const-声明变量" class="section level3">
<h3>3.1 const 声明变量</h3>
<ul>
<li>const 声明与 let 声明唯一一个重要区别是它声明变量时必须同时初始化变量, 且尝试修改 const 声明的变量会导致运行时错误</li>
</ul>
<pre class="js"><code>const age = 26;
age = 36; // TypeError: 给常量赋值</code></pre>
<ul>
<li>const 不允许重复声明</li>
</ul>
<pre class="js"><code>const name = &quot;Matt&quot;;
const name = &quot;John&quot;;
console.log(name); // SyntaxError: Identifier &#39;name&#39; has already been declared</code></pre>
<ul>
<li>const 声明的作用域也是块</li>
</ul>
<pre class="js"><code>const name = &quot;Matt&quot;;
if (true) {
    const name = &quot;Nicholas&quot;;
}
console.log(name); // &quot;Matt&quot;</code></pre>
<ul>
<li>const 声明的限制只适用于它指向的变量的引用, 如果 const 变量引用的是一个对象, 那么修改这个对象内部的属性并不违反 const 对象不能修改变量的限制</li>
</ul>
<pre class="js"><code>const person = {};
person.name = &quot;Matt&quot;; // ok</code></pre>
<ul>
<li>不能用 const 来声明迭代变量(因为迭代变量会自增), JavaScript 引擎会为 for 循环中的 let 声明分别创建独立的变量实例, 但 const 不行; 但是, 如果用 const 声明一个不被修改的 for 循环变量, 那是可以的, 也就是说, 每次迭代只是创建一个新变量, 这对 for-of 和 for-in 循环特别有意义</li>
</ul>
<pre class="js"><code>for (const i = 0; i &lt; 10; ++i) {
    console.log(i); 
}
// TypeError: 给常量赋值

let i = 0;
for (const j = 7; i &lt; 5; ++i) {
    console.log(j);
}
// 7 7 7 7 7

for (const key in {a: 1, b: 2}) {
    console.log(key);
}
// a, b

for (const value of [1, 2, 3, 4, 5]) {
    console.log(value);
}
// 1, 2, 3, 4, 5</code></pre>
</div>
<div id="声明风格及最佳实践" class="section level3">
<h3>3.2 声明风格及最佳实践</h3>
<ul>
<li><p>不使用 var</p>
<ul>
<li>有了 let 和 const, 大多数开发者会发现自己不再需要 var 了。限制自己只使用 let 和 const 有助于提升代码质量, 因为变量有了明确的作用域、声明位置, 以及不变的值。</li>
</ul></li>
<li><p>const 优先, let 次之</p>
<ul>
<li>使用 const 声明可以让浏览器运行时强制保持变量不变, 也可以让静态代码分析工具提前发现不合法的赋值操作。因此, 很多开发者认为应该优先使用 const 来声明变量。</li>
<li>只在提前知道未来会有修改时, 再使用 let。这样可以让开发者更有信心地推断某些变量的值永远不会变, 同时也能迅速发现因意外赋值导致的非预期行为。</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="四数据类型" class="section level1">
<h1>四、数据类型</h1>
<p>ECMAScript 有 6 种简单数据类型(也称为原始类型):</p>
<ul>
<li>Undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
<li>Symbol</li>
</ul>
<p>1 种复杂数据类型:</p>
<ul>
<li><p>Object (对象)</p>
<ul>
<li>无序名值对的集合</li>
</ul></li>
</ul>
<div id="typeof-操作符" class="section level2">
<h2>1.typeof 操作符</h2>
<ul>
<li>因为 ECMAScript 的类型系统是松散的, 所以需要一种手段来确定任意变量的数据类型。typeof 操作符就是为此而生的, 对一个值使用 typeof 操作
<ul>
<li>“undefined” 表示值未定义</li>
<li>“boolean” 表示布尔值</li>
<li>“string” 表示值为字符串</li>
<li>“number” 表示值为数值</li>
<li>“object” 表示值为对象(而不是函数) 或 null</li>
<li>“function” 表示值为函数</li>
<li>“symbol” 表示值为符号</li>
</ul></li>
<li>示例</li>
</ul>
<pre class="js"><code>let message = &quot;some string&quot;;
console.log(typeof message); // &quot;string&quot;
console.log(typeof(message)); // &quot;string&quot;
console.log(typeof 95); // number
console.log(typeof null); // object</code></pre>
</div>
<div id="undefined" class="section level2">
<h2>2.Undefined</h2>
</div>
<div id="null" class="section level2">
<h2>3.Null</h2>
</div>
<div id="boolean" class="section level2">
<h2>4.Boolean</h2>
</div>
<div id="number" class="section level2">
<h2>5.Number</h2>
</div>
<div id="string" class="section level2">
<h2>6.String</h2>
</div>
<div id="symbol" class="section level2">
<h2>7.Symbol</h2>
<ul>
<li>Symbol(符号) 是 ECMAScript 6 新增的数据类型</li>
<li>符号是原始值, 且符号实例是唯一、不可变的</li>
<li>符号的用途是确保对象属性使用唯一标识符, 不会发生属性冲突的危险</li>
<li>尽管听起来跟私有属性有点类似, 但符号并不是为了提供私有属性的行为才增加的(尤其是因为 Object API 提供了方法, 可以更方便地发现符号属性)。相反, 符号就是用来创建唯一记号, 进而用作非字符串形式的对象属性</li>
</ul>
<div id="符号的基本用法" class="section level3">
<h3>7.1 符号的基本用法</h3>
<ul>
<li>符号需要使用 Symbol() 函数初始化。因为符号本身是原始类型, 所以 typeof 操作符对符号返回 symbol</li>
</ul>
<pre class="js"><code>let sym = Symbol();
console.log(typeof sym); // symbol</code></pre>
<ul>
<li>调用 Symbol() 函数时, 可以传入一个字符串参数作为对符号的描述(description), 将来可以通过这个字符串来调试代码, 但是这个字符串参数与符号定义或表示完全无关</li>
</ul>
<pre class="js"><code>let genericSymbol = Symbol();
let otherGenericSymbol = Symbol();
let fooSymbol = Symbol(&quot;foo&quot;);
let otherFooSymbol = Symbol(&quot;foo&quot;);

console.log(genericSymbol == otherGenericSymbol); // false
console.log(fooSymbol == otherFooSymbol); // false</code></pre>
<ul>
<li>符号没有字面量语法, 这也是它们发挥作用的关键。按照规范, 你只要创建 <code>Symbol()</code> 实例并将其用作对象的新属性, 就可以保证它不会覆盖已有的对象属性, 无论是符号属性还是字符串属性。</li>
</ul>
<pre class="js"><code>let genericSymbol = Symbol();
console.log(genericSymbol); // Symbol()

let fooSymbol = Symbol(&quot;foo&quot;);
console.log(fooSymbol); // Symbol(foo)</code></pre>
<ul>
<li>Symbol() 函数不能与 new 关键字一起作为构造函数使用。这样做是为了避免创建符号包装对象, 像使用 Boolean、String 或 Number 那样, 它们都支持构造函数且可用于初始化包含原始值的包装对象</li>
</ul>
<pre class="js"><code>let myBoolean = new Boolean();
console.log(typeof myBoolean); // &quot;object&quot;

let myString = new String();
console.log(typeof myString); // &quot;object&quot;

let myNumber = new Number();
console.log(typeof myNumber); // &quot;object&quot;

let mySymbol = new Symbol(); // TypeError: Symbol is not a constructor

// 使用符号包装对象
let mySymbol = Symbol();
let myWrappedSymbol = Object(mySymbol);
console.log(typeof myWrappedSymbol); // &quot;object&quot;</code></pre>
</div>
<div id="使用全局符号注册表" class="section level3">
<h3>7.2 使用全局符号注册表</h3>
</div>
<div id="使用符号作为属性" class="section level3">
<h3>7.3 使用符号作为属性</h3>
</div>
<div id="常用内置符号" class="section level3">
<h3>7.4 常用内置符号</h3>
</div>
<div id="symbol.asynciterator" class="section level3">
<h3>7.5 Symbol.asyncIterator</h3>
</div>
</div>
<div id="object" class="section level2">
<h2>8.Object</h2>
<ul>
<li><p>ECMAScript 中的<code>对象(object)</code>其实就是一组数据和功能的组合</p></li>
<li><p>严格来讲, ECMA-262 中对象的行为不一定适合 JavaScript 中的其他对象</p>
<ul>
<li>比如浏览器环境中的 BOM 对象 和 DOM 对象, 都是由宿主环境定义和提供的宿主对象</li>
<li>而宿主对象不受 ECMA-262 约束, 所以它们可能会也可能不会继承 Object</li>
</ul></li>
<li><p>对象通过 <code>new</code> 操作符后跟对象类型的名称来创建, 可以通过创建 Object 类型的实例来创建自己的对象, 然后再给对象添加属性和方法</p></li>
<li><p>Object 的实例本身并不是很有用, 但理解与它相关的概念非常重要。类似 Java 中的 java.lang.Object, ECMAScript 中的 Object 也是派生其他对象的基类。Object 类型的所有属性和方法在派生的对象上同样存在。每个Object 实例都有如下属性和方法:</p>
<ul>
<li><p>constructor</p>
<ul>
<li>用于创建当前对象的函数</li>
</ul></li>
<li><p>hasOwnProperty(propertyName)</p>
<ul>
<li>用于判断当前对象实例(不是原型)上是否存在给定的属性。要检查的属性名必须是字符串或符号</li>
</ul></li>
<li><p>isPrototypeOf(object)</p>
<ul>
<li>用于判断当前对象是否为另一个对象的原型</li>
</ul></li>
<li><p>propertyIsEnumerable(propertyName)</p>
<ul>
<li>用于判断给定的属性是否可以使用 for-in 语句枚举。属性名必须是字符串或符号</li>
</ul></li>
<li><p>toLocaleString()</p>
<ul>
<li>返回对象的字符串表示, 该字符反映对象所在的本地化执行环境</li>
</ul></li>
<li><p>toString()</p>
<ul>
<li>返回对象的字符串表示</li>
</ul></li>
<li><p>valueOf()</p>
<ul>
<li>返回对象对应的字符串、数值或布尔值表示。通常与 toString() 的返回值相同</li>
</ul></li>
</ul></li>
</ul>
<pre class="js"><code>let o1 = new Object();
let o2 = new Object; // ECMAScript 只要求在给构造函数提供参数时使用括号, 合法, 但不推荐

o2.name = &quot;wangzf&quot;;
console.log(o2.constructor);
console.log(o2.hasOwnProperty(&quot;name&quot;));
console.log(o2.isPrototypeOf(o1));
console.log(o2.propertyIsEnumerable(&quot;name&quot;));
console.log(o2.toLocaleString());
console.log(o2.toString());
console.log(o2.valueOf(&quot;name&quot;));</code></pre>
</div>
</div>
<div id="五操作符" class="section level1">
<h1>五、操作符</h1>
<p>ECMAScript 中的操作符是独特的, 因为它们可用于各中值, 包括字符串、数值、布尔值、对象。在应用给对象时, 操作符通常会调用 valueOf() 和/或 toString() 方法来取得可以计算的值.</p>
<ul>
<li>数学操作符</li>
<li>位操作符</li>
<li>关系操作符</li>
<li>相等操作符</li>
</ul>
<div id="一元操作符" class="section level2">
<h2>1.一元操作符</h2>
<ul>
<li>递增/递减操作符</li>
<li>一元加和减
<ul>
<li>一元加由一个加号(+)表示,</li>
<li>一元加放在变量前头, 对数值没有任何影响</li>
<li>一元加放在非数值, 则会执行与使用 Number() 转型函数一样的类型转换
<ul>
<li>布尔值 false 和 true 转换为0 和 1</li>
</ul></li>
</ul></li>
</ul>
</div>
<div id="位操作符" class="section level2">
<h2>2.位操作符</h2>
</div>
<div id="布尔操作符" class="section level2">
<h2>3.布尔操作符</h2>
<ul>
<li><p>语法</p>
<ul>
<li><p>逻辑非 <code>!</code></p>
<ul>
<li><p>这个操作符始终返回布尔值, 无论应用的是什么数据类型, 逻辑非操作符首先将操作数转换为布尔值, 然后再对其取反</p></li>
<li><p>规则</p>
<table>
<thead>
<tr class="header">
<th>表达式</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>!对象</td>
<td>false</td>
</tr>
<tr class="even">
<td>!空字符串</td>
<td>true</td>
</tr>
<tr class="odd">
<td>!非空字符串</td>
<td>false</td>
</tr>
<tr class="even">
<td>!0</td>
<td>true</td>
</tr>
<tr class="odd">
<td>!非0数值(包括Infinity)</td>
<td>false</td>
</tr>
<tr class="even">
<td>!null</td>
<td>true</td>
</tr>
<tr class="odd">
<td>!NaN</td>
<td>true</td>
</tr>
<tr class="even">
<td>!undefined</td>
<td>true</td>
</tr>
</tbody>
</table></li>
<li><p><code>!!</code>: 相当于调用了转型函数 Boolean() , 无论操作数是什么类型, 第一个叹号总会返回布尔值, 第二个叹号对该布尔值取反, 从而给出变量真正对应的布尔值, 结果与对同一个值使用 Boolean() 函数是一样的</p>
<ul>
<li>示例</li>
</ul>
<pre class="js"><code>console.log(!!&quot;blue&quot;); // true
console.log(!!0); // false
console.log(!!NaN); // false
console.log(!!&quot;&quot;); // false
console.log(!!12345); // true</code></pre></li>
</ul></li>
<li><p>逻辑与 <code>&amp;&amp;</code></p>
<ul>
<li><p>逻辑与操作符遵循的真值表</p>
<table>
<thead>
<tr class="header">
<th>第一个操作数</th>
<th>第二个操作数</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr class="even">
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr class="odd">
<td>false</td>
<td>true</td>
<td>false</td>
</tr>
<tr class="even">
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
</tbody>
</table></li>
<li></li>
</ul></li>
<li><p>逻辑或 <code>||</code></p>
<ul>
<li><p>逻辑或操作符遵循的真值表</p>
<table>
<thead>
<tr class="header">
<th>第一个操作数</th>
<th>第二个操作数</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr class="even">
<td>true</td>
<td>false</td>
<td>true</td>
</tr>
<tr class="odd">
<td>false</td>
<td>true</td>
<td>true</td>
</tr>
<tr class="even">
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
</tbody>
</table></li>
<li></li>
</ul></li>
</ul></li>
</ul>
</div>
<div id="乘性操作符" class="section level2">
<h2>4.乘性操作符</h2>
</div>
<div id="指数操作符" class="section level2">
<h2>5.指数操作符</h2>
</div>
<div id="加性操作符" class="section level2">
<h2>6.加性操作符</h2>
</div>
<div id="关系操作符" class="section level2">
<h2>7.关系操作符</h2>
</div>
<div id="相等操作符" class="section level2">
<h2>8.相等操作符</h2>
<ul>
<li>在比较字符串、数值和布尔值是否相等时, 过程都很直观。但是在比较两个对象是否相等时, 情形就比较复杂了</li>
<li>ECMAScript 中的相等和不相等操作符, 原本在比较之前会执行类型转换, 但很快就有人质疑这种转换是否应该发生。最终, ECMAScript 提供了两组操作符, 第一组是等于和不等于, 它们在比较之前执行转换(强制类型转换)。第二组是全等和不全等, 它们在比较之前不执行转换</li>
</ul>
<div id="等于和不等于" class="section level3">
<h3>8.1 等于和不等于</h3>
<ul>
<li>语法
<ul>
<li><code>==</code></li>
<li><code>!=</code></li>
</ul></li>
<li>规则
<ul>
<li><ol style="list-style-type: decimal">
<li>如果任一操作数是布尔值, 则将其转换为数值再比较是否相等。false转换为0, true转换为1</li>
</ol></li>
<li><ol start="2" style="list-style-type: decimal">
<li>如果一个操作数是字符串, 另一个操作数不是, 则尝试将字符串转换为数值, 再比较是否相等</li>
</ol></li>
<li><ol start="3" style="list-style-type: decimal">
<li>如果一个操作数是对象, 另一个操作数不是, 则调用对象的 valueOf() 方法取得其原始值, 再根据前面的规则进行比较</li>
</ol></li>
<li><ol start="4" style="list-style-type: decimal">
<li>null 和 undefined 相等</li>
</ol></li>
<li><ol start="5" style="list-style-type: decimal">
<li>null 和 undefined 不能转换为其他类型的值再进行比较</li>
</ol></li>
<li><ol start="6" style="list-style-type: decimal">
<li>如果有任一操作数是 NaN,则相等操作符返回 false, 不相等操作符返回 true。记住: 即使两个操作数都是NaN, 相等操作符也返回 false, 因为按照规则, NaN 不等于 NaN</li>
</ol></li>
<li><ol start="7" style="list-style-type: decimal">
<li>如果两个操作数都是对象, 则比较它们是不是同一个对象。如果两个操作数都指向同一个对象, 则相等操作符返回 true, 否则, 两者不相等</li>
</ol></li>
</ul></li>
<li>示例</li>
</ul>
<table>
<thead>
<tr class="header">
<th>表达式</th>
<th>结果</th>
<th>遵循的规则</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>null == undefined</td>
<td>true</td>
<td>(4)</td>
</tr>
<tr class="even">
<td>“NaN” == NaN</td>
<td>false</td>
<td>(6)</td>
</tr>
<tr class="odd">
<td>5 == NaN</td>
<td>false</td>
<td>(6)</td>
</tr>
<tr class="even">
<td>NaN == NaN</td>
<td>fasle</td>
<td>(6)</td>
</tr>
<tr class="odd">
<td>NaN != NaN</td>
<td>true</td>
<td>(6)</td>
</tr>
<tr class="even">
<td>false == 0</td>
<td>true</td>
<td>(1)</td>
</tr>
<tr class="odd">
<td>true == 1</td>
<td>true</td>
<td>(1)</td>
</tr>
<tr class="even">
<td>true == 2</td>
<td>false</td>
<td>(1)</td>
</tr>
<tr class="odd">
<td>undefined == 0</td>
<td>false</td>
<td>(4)</td>
</tr>
<tr class="even">
<td>null == 0</td>
<td>false</td>
<td>(4)</td>
</tr>
<tr class="odd">
<td>“5” == 5</td>
<td>true</td>
<td>(2)</td>
</tr>
</tbody>
</table>
</div>
<div id="全等和不全等" class="section level3">
<h3>8.2 全等和不全等</h3>
<ul>
<li>语法
<ul>
<li><code>===</code></li>
<li><code>!==</code></li>
</ul></li>
<li>示例</li>
</ul>
<pre class="js"><code>let result1 = (&quot;55&quot; == 55); // true, 转换后相等
let result2 = (&quot;55&quot; === 55); // false, 不相等, 因为数据类型不同</code></pre>
<pre class="js"><code>let result1 = (&quot;55&quot; != 55); // false, 转换后相等
let result2 = (&quot;55&quot; !=== 55); // true, 不相等, 因为数据类型不同</code></pre>
<ul>
<li>示例</li>
</ul>
<table>
<thead>
<tr class="header">
<th>表达式</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>null == undefined</td>
<td>true</td>
</tr>
<tr class="even">
<td>null === undefined</td>
<td>false</td>
</tr>
</tbody>
</table>
<blockquote>
<p>由于相等和不相等操作符存在类型转换问题, 因此推荐使用全等和不全等操作符。这样有助于在代码中保持数据类型的完整性.</p>
</blockquote>
</div>
</div>
<div id="条件操作符" class="section level2">
<h2>9.条件操作符</h2>
<ul>
<li>语法</li>
</ul>
<pre class="js"><code>variable = boolean_expression ? true_value : false_value;</code></pre>
<ul>
<li>示例</li>
</ul>
<pre class="js"><code>let max = (num1 &gt; num2) ? num1 : num2;</code></pre>
</div>
<div id="赋值操作符" class="section level2">
<h2>10.赋值操作符</h2>
<ul>
<li>简单赋值
<ul>
<li><code>=</code></li>
</ul></li>
<li>复合赋值
<ul>
<li><code>*=</code></li>
<li><code>/=</code></li>
<li><code>%=</code></li>
<li><code>+=</code></li>
<li><code>-=</code></li>
<li>左移后赋值 <code>&lt;&lt;=</code></li>
<li>右移后赋值 <code>&gt;&gt;=</code></li>
<li>无符号右移后赋值 <code>&gt;&gt;&gt;=</code></li>
</ul></li>
<li>示例:</li>
</ul>
<pre class="js"><code>let num = 10;
num = num + 10;
console.log(num);</code></pre>
<p>等价于:</p>
<pre class="js"><code>let num = 10;
num += 10;</code></pre>
</div>
<div id="逗号操作符" class="section level2">
<h2>11. 逗号操作符</h2>
<ul>
<li><p>逗号操作符可以用来在一条语句中执行多个操作</p>
<ul>
<li>在一条语句中同时声明多个变量是逗号操作符最常用的场景</li>
<li>也可以使用逗号操作符来辅助赋值。在赋值时使用逗号操作符分隔值, 最终会返回表达式中最后一个值</li>
</ul></li>
</ul>
<pre class="js"><code>let num1 = 1, num2 = 2, num3 = 3;
console.log(num1); // 1
console.log(num2); // 2
console.log(num3); // 3

let num = (5, 1, 4, 8, 0); 
console.log(num);  // 0</code></pre>
</div>
</div>
<div id="六语句" class="section level1">
<h1>六、语句</h1>
<div id="if" class="section level2">
<h2>1.if</h2>
<ul>
<li>语法</li>
</ul>
<pre class="js"><code>if (condition) statement1 else statement2
if (condition) statement1 else if (condition2) statement2 else statement3</code></pre>
</div>
<div id="do-while" class="section level2">
<h2>2.do-while</h2>
<ul>
<li>do-while 语句是一种后测试循环语句, 即循环体中的代码执行后才会对退出条件进行求值。换句话说, 循环体内的代码至少执行一次</li>
<li>语法</li>
</ul>
<pre class="js"><code>do {
    statement
} while (expression);</code></pre>
</div>
<div id="while" class="section level2">
<h2>3.while</h2>
<ul>
<li>语法</li>
</ul>
<pre class="js"><code>while (expression) statement</code></pre>
</div>
<div id="for" class="section level2">
<h2>4.for</h2>
<ul>
<li>语法</li>
</ul>
<pre class="js"><code>for (initialization; expression; post-loop-expression) statement</code></pre>
<ul>
<li>在 for 循环的初始化代码中, 其实是可以不使用变量声明关键字的。不过, 初始化定义的迭代器变量在循环执行完后几乎不可能再用到了。因此, 最清晰的写法是使用 let 声明迭代器变量, 这样就可以将这个变量的作用域限定在循环中</li>
<li>初始化、条件表达式和循环后表达式都不是必需的</li>
</ul>
<pre class="js"><code>for (;;) {// 无穷循环
    doSomething();
}</code></pre>
<ul>
<li>如果只包含条件表达式, 那么 for 循环实际上就变成了 while 循环</li>
</ul>
<pre class="js"><code>let count = 10;
let i = 0;
for (; i &lt; count; ) {
    console.log(i);
    i++;
}</code></pre>
</div>
<div id="for-in" class="section level2">
<h2>5.for-in</h2>
<ul>
<li>for-in 语句是一种严格的迭代语句, 用于枚举对象中的非符号键属性</li>
<li>ECMAScript 中的对象的属性是无序的, 因此 for-in 语句不能保证返回对象属性的顺序。换句话说, 所有可枚举的属性都会返回一次, 但返回的顺序可能会因浏览器而异</li>
<li>如果 for-in 循环要迭代的变量是 null 或 undefined, 则不执行循环体</li>
<li>语法</li>
</ul>
<pre class="js"><code>for (property in expression) statement</code></pre>
<ul>
<li>示例</li>
</ul>
<pre class="js"><code>for (const propName in window) { // 控制语句中的 const 不是必需的, 但是为了确保这个局部变量不被修改, 推荐使用 const
    document.write(propName);
}</code></pre>
</div>
<div id="for-of" class="section level2">
<h2>6.for-of</h2>
<ul>
<li>for-of 语句是一种严格的迭代语句, 用于遍历可迭代对象的元素</li>
<li>语法</li>
</ul>
<pre class="js"><code>for (property of expression) statement</code></pre>
<ul>
<li>示例</li>
</ul>
<pre class="js"><code>for (const el of [2, 4, 6, 8]) {// 控制语句中的 const 不是必需的, 但是为了确保这个局部变量不被修改, 推荐使用 const
    document.write(el);
}</code></pre>
</div>
<div id="label" class="section level2">
<h2>7.label</h2>
<ul>
<li>标签语句用于给语句加标签, 标签可以在语句后面通过 break 或 continue 语句引用</li>
<li>标签语句的典型应用场景是嵌套循环</li>
<li>语法</li>
</ul>
<pre class="js"><code>label: statement</code></pre>
<ul>
<li>示例</li>
</ul>
<pre class="js"><code>start: for (let i = 0; i &lt; count; i++) {
    console.log(i);
}</code></pre>
</div>
<div id="break" class="section level2">
<h2>8.break</h2>
</div>
<div id="continue" class="section level2">
<h2>9.continue</h2>
</div>
<div id="with" class="section level2">
<h2>10.with</h2>
<ul>
<li>with 语句的用途是将代码作用域设置为特定的对象</li>
<li>语法</li>
</ul>
<pre class="js"><code>with (expression) statement;</code></pre>
</div>
<div id="switch" class="section level2">
<h2>11.switch</h2>
</div>
</div>
<div id="七函数" class="section level1">
<h1>七、函数</h1>
<div id="函数基本知识" class="section level2">
<h2>1.函数基本知识</h2>
<ul>
<li>语法</li>
</ul>
<pre class="js"><code>function functionName(arg0, arg1, ..., argN) {
    statements
}</code></pre>
<ul>
<li>示例</li>
</ul>
<pre class="js"><code>function sayHi(name, message) {
    console.log(&quot;Hello &quot; + name + &quot;, &quot; + message);
}
sayHi(&quot;Nicholas&quot;, &quot;how are you today?&quot;);</code></pre>
<script type="text/javascript">
function sayHi(name, message) {
    console.log("Hello " + name + ", " + message);
}
sayHi("Nicholas", "how are you today?");
</script>
<ul>
<li>ECMAScript 中的函数不需要指定是否返回值, 任何函数在任何时间都可以使用 return 语句来返回函数的值, 用法是后跟要返回的值, 只要碰到 return 语句, 函数就立即停止执行并退出</li>
</ul>
<pre class="js"><code>function sum(num1, num2) {
    return num1 + num2;
}
const result = sum(5, 10);

function sum(num1, num2) {
    return num1 + num2;
    console.log(&quot;Hello world&quot;); // 不会执行
}

function diff(num1, num2) {
    if (num1 &lt; num2) {
        return num2 - num1;
    } else {
        return num1 - num2;
    }
}

function sayHi(name, message) {
    return;
    console.log(&quot;Hello &quot; + name + &quot;, &quot; + message); // 不会执行
}</code></pre>
<ul>
<li><p>最佳实践是函数要么返回值, 要么不返回值。只在某个条件下返回值的函数会带来麻烦, 尤其是调试时</p></li>
<li><p>严格模式对函数也有一些限制:</p>
<ul>
<li>函数不能以 eval 或 arguments 作为名称</li>
<li>函数的参数不能叫做 eval 或 arguments</li>
<li>两个命名参数不能拥有同一个名称</li>
</ul></li>
</ul>
</div>
<div id="函数对象" class="section level2">
<h2>2.函数对象</h2>
<ul>
<li><p>每个函数都是 Function 类型的实例, 而 Function 也有属性和方法, 跟其他引用类型一样。因为函数时对象, 所以函数名就是指向函数对象的指针, 而且不一定与函数本身紧密绑定。有三种函数定义方法:</p>
<ol style="list-style-type: decimal">
<li>函数通常以函数声明的方式定义</li>
</ol>
<pre class="js"><code>function sum(num1, num2) {
    return num1 + num2;
}</code></pre>
<ol style="list-style-type: decimal">
<li>另一种定义函数的语法是函数表达式(与函数声明等价)</li>
</ol>
<pre class="js"><code>let sum = function (num1, num2) {
    return num1 + num2;
};</code></pre>
<ol style="list-style-type: decimal">
<li>还有一种定义函数的方式与函数表达式很像, 叫作”箭头函数(arrow function)”</li>
</ol>
<pre class="js"><code>let sum = (num1, num2) =&gt; {
    return num1 + num2;
};</code></pre>
<ol style="list-style-type: decimal">
<li>最后一种定义函数的方式是使用 Function 构造函数。这个构造函数接收任意多个字符串参数, 最后一个参数始终会被当成函数体, 而之前的参数都是新函数的参数, 不推荐使用, 会影响性能</li>
</ol>
<pre class="js"><code>let sum = new Function(&quot;num1&quot;, &quot;num2&quot;, &quot;return num1 + num2&quot;); // 不推荐</code></pre></li>
</ul>
</div>
<div id="箭头函数" class="section level2">
<h2>3.箭头函数</h2>
<ul>
<li>ECMAScript 6 新增了使用胖箭头(=&gt;)语法定义函数表达式的能力</li>
</ul>
<pre class="js"><code>let arrowSum = (a, b) =&gt; {
    return a + b;
};

let functionExpressionSum = function(a, b) {
    return a + b;
};

console.log(arrowSum(5, 8)); // 13
console.log(functionExpressionSum(5, 8)); // 13</code></pre>
<ul>
<li>箭头函数简介的语法非常适合嵌入函数的场景</li>
</ul>
<pre class="js"><code>let ints = [1, 2, 3];
console.log(ints.map(function(i) { return i + 1; })); // [2, 3, 4]
console.log(ints.map((i) =&gt; { return i + 1; })); // [2, 3, 4]</code></pre>
<ul>
<li>箭头函数的参数形式、函数体形式</li>
</ul>
<pre class="js"><code>// 如果只有一个参数, 可以不用括号, 只有没有参数, 或者多个参数的情况下, 才需要使用括号
let double = (x) =&gt; { return 2 * x; };
let tirple = x =&gt; { return 3 * x; };
let getRandom = () =&gt; { return Math.random(); };
let sum = (a, b) =&gt; { return a + b; };

// 箭头后面只有一行代码, 使用大括号就说明包含“函数体”, 可以在一个函数中包含多条语句, 如果不适用大括号, 那么箭头后面就只能有一行代码, 不如一个赋值操作, 或者一个表达式
let double = (x) =&gt; { return 2 * x; };
let triple = (x) =&gt; 3 * x;

// 可以赋值
let value = {};
let setName = (x) =&gt; x.name = &quot;Matt&quot;;
setName(value);
console.log(value.name); // &quot;Matt&quot;</code></pre>
<ul>
<li><p>箭头函数虽然语法简洁, 但也有很多场合不适用</p>
<ul>
<li>箭头函数不能使用 arguments、super、new.target</li>
<li>箭头函数不能用作构造函数</li>
<li>箭头函数也没有 prototype 属性</li>
</ul></li>
</ul>
</div>
<div id="函数名" class="section level2">
<h2>4.函数名</h2>
<ul>
<li><p>因为函数名就是指向函数的指针, 所以它们跟其他包含对象指针的变量具有相同的行为。这意味着一个函数可以有多个名称</p>
<ul>
<li>使用不带括号的函数名会访问函数指针, 而不会执行函数</li>
</ul></li>
</ul>
<pre class="js"><code>// sum
function sum(num1, num2) {
    return num1 + num2;
}
console.log(sum(10, 10)); // 20

// anotherSum
let anotherSum = sum;
console.log(anotherSum(10, 10)); // 20

sum = null;
console.log(anotherSum(10, 10)); // 20</code></pre>
<ul>
<li><p>ECMAScript 6 的所有函数对象都会暴露一个只读的 name 属性, 其中包含关于函数的信息</p>
<ul>
<li>多数情况下, 这个 name 属性中保存的就是一个函数标识符, 或者说是一个字符串化的变量名。即使函数没有名称, 也会如实显示成空字符串</li>
<li>如果函数是使用 Function 构造函数创建的, 则会标识成 “anonymous”</li>
</ul></li>
</ul>
<pre class="js"><code>function foo() {}        // fun 1
let bar = function() {}; // fun 2
let baz = () =&gt; {};      // fun 3

console.log(foo.name);              // foo
console.lof(bar.name);              // bar
console.log((() =&gt; {}).name);       // (空字符串)
console.log((new Function()).name); // anonymous</code></pre>
<ul>
<li>如果函数时一个获取函数、设置函数, 或者使用 bind() 实例化, 那么标识符前面会加上一个前缀</li>
</ul>
<pre class="js"><code>function foo() {};
console.log(foo.bind(null).name); // bound foo</code></pre>
<pre class="js"><code>let dog = {
    year: 1,
    get age() {
        return this.years;
    },
    set age(newAge) {
        this.years = newAge;
    }
}
let propertyDescriptor = Object.getOwnPropertyDescriptor(dog, &quot;age&quot;);
console.log(propertyDescriptor.get.name); // get age
console.log(propertyDescriptor.set.name); // set age</code></pre>
</div>
</div>
