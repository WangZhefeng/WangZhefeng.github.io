---
title: 第五章、基本引用类型
author: 王哲峰
date: '2020-03-01'
slug: js-basic-reference
categories:
  - 前端
tags:
  - tool
output:
  blogdown::html_page:
    toc: true
    fig_width: 6
    dev: "svg"
---

<script src="{{< blogdown/postref >}}index_files/header-attrs/header-attrs.js"></script>

<div id="TOC">
<ul>
<li><a href="#date">1.Date</a>
<ul>
<li><a href="#继承的方法">1.1 继承的方法</a></li>
<li><a href="#日期格式化方法">1.2 日期格式化方法</a></li>
<li><a href="#日期时间组件方法">1.3 日期/时间组件方法</a></li>
</ul></li>
<li><a href="#regexp">2.RegExp</a>
<ul>
<li><a href="#regexp-实例属性">2.1 RegExp 实例属性</a></li>
<li><a href="#regexp-实例方法">2.2 RegExp 实例方法</a></li>
<li><a href="#regexp-构造函数属性">2.3 RegExp 构造函数属性</a></li>
<li><a href="#模式局限">2.4 模式局限</a></li>
</ul></li>
<li><a href="#原始值包装类型">3.原始值包装类型</a>
<ul>
<li><a href="#boolean">3.1 Boolean</a></li>
<li><a href="#number">3.2 Number</a></li>
<li><a href="#string">3.3 String</a></li>
</ul></li>
<li><a href="#单例内置对象">4.单例内置对象</a>
<ul>
<li><a href="#global">4.1 Global</a></li>
<li><a href="#math">4.2 Math</a></li>
</ul></li>
</ul>
</div>

<ul>
<li>引用值(或者对象)是某个特定<strong>引用类型</strong>的<strong>实例</strong>
<ul>
<li>在 ECMAScript 中，<strong>引用类型</strong>是把数据和功能组织到一起的结构，经常被人错误地称作“类”</li>
<li><strong>引用类型</strong>有时候也被称为<strong>对象定义</strong>，因为它们描述了自己的对象应有的属性和方法</li>
</ul></li>
<li>对象被认为是某个<strong>特定引用类型</strong>的<strong>实例</strong></li>
<li>新对象通过使用 <code>new</code> 操作符后跟一个<strong>构造函数(constructor)</strong>来构建。构造函数就是用来创建新对象的函数</li>
<li>ECMAScript 提供了很多的<strong>原生引用类型</strong>，帮助开发者实现常见的任务
<ul>
<li>Date</li>
<li>Regexp</li>
<li>Function</li>
</ul></li>
</ul>
<div id="date" class="section level2">
<h2>1.Date</h2>
<ul>
<li><p>ECMAScript 的 Date 类型参考了 Java 早期版本中的 java.util.Date。为此，Date 类型将日期保存为自协调世界时(UTC，Universal Time Coordinated)时间 1970 年 1 月 1 日午夜(零时)至今所经过的毫秒数。使用这种存储格式，Date 类型可以精确表示 1970 年 1 月 1 日之前及之后 285616 年的日期。</p></li>
<li><p>创建日期对象</p>
<ul>
<li><p>在不给 Date 构造函数传参数的情况下，创建的对象将保存当前日期和时间</p></li>
<li><p>要基于其他日期和时间创建日期对象，比如传入其毫秒表示(UNIX 纪元 1970 年 1 月 1 日 午夜之后的毫秒数)，ES 为此提供了两个辅助函数</p>
<ul>
<li>Date.parse()
<ul>
<li>接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数</li>
<li>ECMA-262 第 5 版定义了 Date.parse() 应该支持的日期格式，所有实现都必须支持下列日期格式
<ul>
<li>“月/日/年”，如 “5/23/2019”</li>
<li>“月名 日, 年”，如 “May 23, 2019”</li>
<li>“周几 月名 日 年 时:分:秒 时区”，如 “Tue May 23 2019 00:00:00 GMT-0700”</li>
<li>ISO 8601 扩展格式 “YYYY-MM-DDTHH:mm:ss.sssZ”，如 “2019-05-23T00:00:00”</li>
</ul></li>
<li>如果传给 Date.parse() 的字符串并不表示日期，则该方法会返回 NaN</li>
<li>如果直接把表示日期的字符串传给 Date 构造函数，那么 Date 会在后台调用 Date.parse()</li>
</ul></li>
</ul>
<pre class="js"><code>// 当前日期和时间
let now = new Date();

let someDate = new Date(Date.parse(&quot;May 23, 2019&quot;));
// 等价
let someDate = new Date(&quot;May 23, 2019&quot;);</code></pre>
<ul>
<li>Date.UTC()
<ul>
<li>Date.UTC() 方法返回日期的毫秒表示，但使用的是跟 Date.parse() 不同的信息来生成这个值</li>
<li>传给 Date.UTC() 的参数是
<ul>
<li>年–必需</li>
<li>零起点月数(1月是0，2月是1，以此类推)–必需</li>
<li>日(1~31)–默认1</li>
<li>时(0~23)–默认00</li>
<li>分–默认00</li>
<li>秒–默认00</li>
<li>毫秒–默认000</li>
</ul></li>
<li>与 Date.parse() 一样，Date.UTC() 也会被 Date 构造函数隐式调用，但有一个区别：这种情况下创建的是本地时间，不是 GMT 日期。不过 Date 构造函数跟 Date.UTC() 接收的参数是一样的。因此，因此第一个参数是数值，则构造函数假设它是日期中的年，第二个参数是月，以此类推</li>
</ul></li>
</ul>
<pre class="js"><code>// GMT 时间 2000年1月1日零点
let y2k = new Date(Date.UTC(2000, 0));
// GMT 时间 2005年5月5日下午5点55分55秒
let allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));
// 本地时间 2000年1月1日零点
let y2k_2 = new Date(2000, 0);
// 本地时间 时间 2005年5月5日下午5点55分55秒
let allFives_local = new Date(2005, 4, 5, 17, 55, 55);</code></pre></li>
<li><p>ECMAScript 还提供了 Date.now() 方法，返回表示方法执行时日期和时间的毫秒数</p>
<pre class="js"><code>// 起始时间
let start = Date.now();
// 调用函数
doSomething();
// 结束时间
let stop = Date.now();
result = stop - start;</code></pre></li>
</ul></li>
</ul>
<div id="继承的方法" class="section level3">
<h3>1.1 继承的方法</h3>
<ul>
<li>Date 类型重写了 toLocaleString()、toString()、valueOf() 方法，但与其他类型不同，重写这些方法的返回值不一样
<ul>
<li>toLocaleString() 方法返回与浏览器运行的本地环境一致的日期和时间，这通常意味着格式中包含针对时间的 AM(上午)或PM(下午)，但不包含时区信息(具体格式可能因浏览器而不同)</li>
<li>toString() 方法通常返回带时区信息的日期和时间，而时间也是以 24小时制(0~23)表示的</li>
<li>valueOf() 方法根本就不返回字符串，这个方法被重写后返回的是日期的毫秒表示，因此，操作符(如大于号和小于号)可以直接使用它返回的值</li>
</ul></li>
</ul>
<pre class="js"><code>toLocaleString() // 2/1/2019 12:00:00 
AMtoString()       // Thu Feb 1 2019 00:00:00 GMT-0800 (Pacific Standard Time)
let date1 = new Date(2019, 0, 1); // 2019年1月1日
let date2 = new Date(2019, 1, 1); // 2019年2月1日
console.log(date1 &lt; date2); // true
console.log(date1 &gt; date2); // false</code></pre>
</div>
<div id="日期格式化方法" class="section level3">
<h3>1.2 日期格式化方法</h3>
<ul>
<li>Date 类型有几个专门用于格式化日期的方法，它们都返回字符串</li>
</ul>
<p><img src="/Users/zfwang/Library/Application%20Support/typora-user-images/image-20210413001515385.png" alt="image-20210413001515385" style="zoom:50%;" /></p>
</div>
<div id="日期时间组件方法" class="section level3">
<h3>1.3 日期/时间组件方法</h3>
<ul>
<li>Date 类型还有直接涉及取得或设置日期值的特定部分</li>
</ul>
<p><img src="/Users/zfwang/Library/Application%20Support/typora-user-images/image-20210413001131754.png" alt="image-20210413001131754" style="zoom: 33%;" /></p>
<p><img src="/Users/zfwang/Library/Application%20Support/typora-user-images/image-20210413001221806.png" alt="image-20210413001221806" style="zoom: 33%;" /></p>
</div>
</div>
<div id="regexp" class="section level2">
<h2>2.RegExp</h2>
<ul>
<li><p>ECMAScript 正则表达式语法</p>
<ul>
<li><p>正则表达式的 <code>pattern</code> (模式)可以是任何简单或复杂的正则表达式，包括字符类、限定符、分组、向前查找、反向引用</p></li>
<li><p>每个正则表达式可以带零个或多个 <code>flag</code>(标记)，用于控制正则表达式的行为:</p>
<ul>
<li><code>g</code> 全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束</li>
<li><code>i</code> 不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写</li>
<li><code>m</code> 多行模式，表示查找到一行文本末尾时会继续查找</li>
<li><code>y</code> 粘贴模式，表示只查找从 lastIndex 开始以之后的字符串</li>
<li><code>u</code> Unicode 模式，启用 Unicode 匹配</li>
<li><code>s</code> dotAll 模式，表示元字符. 匹配任何字符(包括 或 </li>
</ul></li>
<li><p>所有元字符在模式中必须转义</p>
<ul>
<li>(</li>
<li>)</li>
<li>[</li>
<li>]</li>
<li>{</li>
<li>}</li>
<li><br />
</li>
<li>^</li>
<li>$</li>
<li><div class="line-block"></div></li>
<li>?</li>
<li><ul>
<li></li>
</ul></li>
<li><ul>
<li></li>
</ul></li>
<li>.</li>
</ul></li>
<li><p>任何使用字面量定义的正则表达式也可以使用 <code>RegExp</code> 构造函数来创建，它接收两个参数：</p>
<ul>
<li><p>模式字符串</p></li>
<li><p>可选的标记字符串</p></li>
<li><p>因为 RegExp 的模式参数是字符串，所以在某些情况下需要二次转义。所有元字符都必须二次转义，包括转义字符序列</p>
<table>
<thead>
<tr class="header">
<th>字面量模式</th>
<th>对应的字符串</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>/\[bc\]at/</code></td>
<td><code>\\[bc\\]at</code></td>
</tr>
<tr class="even">
<td><code>/\.at/</code></td>
<td><code>\\.at</code></td>
</tr>
<tr class="odd">
<td><code>/name\/age/\</code></td>
<td><code>name\\/age</code></td>
</tr>
<tr class="even">
<td><code>/\d.\d{1,2}/</code></td>
<td><code>\\d.\\d{1,2}</code></td>
</tr>
<tr class="odd">
<td><code>/\w\\hello\\123/</code></td>
<td><code>\\w\\\\\hello\\\\123</code></td>
</tr>
</tbody>
</table></li>
<li><p>使用 RegExp 可以基于已有的正则表达式实例，并可选择性地修改它们的标记</p></li>
</ul></li>
</ul></li>
</ul>
<pre class="js"><code>// 字面量
let expression = /pattern/flags;
// 构造函数
let expression = new RegExp(/pattern, /flag)</code></pre>
<ul>
<li>示例</li>
</ul>
<pre class="js"><code>// 匹配字符串中的所有 &quot;at&quot;
let pattern1 = /at/g;
// 匹配第一个 &quot;bat&quot; 或 &quot;cat&quot;，忽略大小写
let pattern2 = /[bc]at/i;
// 匹配所有以 &quot;at&quot; 结尾的三字符组合，忽略大小写
let pattern3 = /.at/gi;
// 匹配第一个 &quot;[bc]at&quot;，忽略大小写
let pattern4 = /\[bc\]at/i;
// 匹配所有 &quot;.at&quot;，忽略大小写
let pattern5 = /\.at/gi;
// 匹配第一个 &quot;bat&quot; 或 &quot;cat&quot;，忽略大小写
let pattern6 = new RegExp(&quot;[bc]at&quot;, &quot;i&quot;);
const re1 = /cat/g;console.log(re1); // &quot;/cat/g&quot;
const re2 = new RegExp(rel1);
console.log(re2); // &quot;/cat/g&quot;

const re3 = new RegExp(re1, &quot;i&quot;)
console.log(re3); // &quot;/cat/i&quot;</code></pre>
<div id="regexp-实例属性" class="section level3">
<h3>2.1 RegExp 实例属性</h3>
<ul>
<li><p>每个 RegExp 实例都有下列属性，通过这些属性可以全面了解正则表达式的信息，不过实际开发中用得不多，因为模式声明中包含这些信息</p>
<ul>
<li>global 布尔值，表示是否设置了 g 标记</li>
<li>ignoreCase 布尔值，表示是否设置了 i 标记</li>
<li>unicode 布尔值，表示是否设置了 u 标记</li>
<li>sticky 布尔值，表示是否设置了 y 标记</li>
<li>lastIndex 整数，表示在元字符中下一次搜索的开始位置，始终从 0 开始</li>
<li>multiline 布尔值，表示是否设置了 m 标记</li>
<li>dotAll 布尔值，表示是否设置了 s 标记</li>
<li>source 正则表达式的字面量字符串(不是传给构造函数的模式字符串)，没有开头和结尾的斜杆</li>
<li>flags 正则表达式的标记字符串，始终以字面量而非传入构造函数的字符串模式形式返回(没有前后斜杆)</li>
</ul>
<pre class="js"><code>let pattern1 = /\[bc\]at/i;
console.log(pattern1.global); // false
console.log(pattern1.ignoreCase); // true
console.log(pattern1.multiline); // false
console.log(pattern1.lastIndex); // 0
console.log(pattern1.source); // &quot;\[bc\]at&quot;
console.log(pattern1.flags); // &quot;i&quot;
let pattern2 = new RegExp(&quot;\\[bc\\]at&quot;, &quot;i&quot;);
console.log(pattern2.global);      // false
console.log(pattern2.ignoreCase);  // true 
console.log(pattern2.multiline); // false
console.log(pattern2.lastIndex);//0
console.log(pattern2.source); // &quot;\[bc\]at&quot; 
console.log(pattern2.flags); // &quot;i&quot;</code></pre></li>
</ul>
</div>
<div id="regexp-实例方法" class="section level3">
<h3>2.2 RegExp 实例方法</h3>
<p>#TODO</p>
</div>
<div id="regexp-构造函数属性" class="section level3">
<h3>2.3 RegExp 构造函数属性</h3>
<p>#TODO</p>
</div>
<div id="模式局限" class="section level3">
<h3>2.4 模式局限</h3>
<ul>
<li>虽然 ECMAScript 对正则表达式的支持有了长足的进步，但仍然缺少 Perl 语言中的一些高级特性。 下列特性目前还没有得到 ECMAScript 的支持
<ul>
<li>和 锚（分别匹配字符串的开始和末尾）</li>
<li>联合及交叉类</li>
<li>原子组</li>
<li>x （忽略空格）匹配模式</li>
<li>条件匹配</li>
<li>正则表达式注释</li>
</ul></li>
</ul>
</div>
</div>
<div id="原始值包装类型" class="section level2">
<h2>3.原始值包装类型</h2>
<ul>
<li><p>为了方便操作原始值，ECMAScript 提供了 3 种特殊的引用类型，原始包装类型：</p>
<ul>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
</ul>
<p>这些类型具有引用类型一样的特点，但也具有与各自原始类型对应的特殊行为，每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象(Boolean, Number, String类型的实例)，从而暴露出操作原始值的各种方法</p></li>
<li><p>当在原始值上调用方法时，实际上是以读模式访问的，也就是要从内存中读取变量保存的值。在以读模式访问原始值的任何时候，后台都会执行以下 3 步，这种行为可以让原始值拥有对象的行为：</p>
<ul>
<li>（1）创建一个 Boolean/Number/String 类型的实例</li>
<li>（2）调用实例上的特定方法</li>
<li>（3）销毁实例</li>
</ul></li>
</ul>
<pre class="js"><code>// JavaScript 代码
let s1 = &quot;some text&quot;;      // 原始值
let s2 = s1.substring(2);  // 原始值上调用 substring 方法

// 上面的代码与下面的步骤等价

// ECMAScript 代码
let s1 = new String(&quot;some text&quot;);
let s2 = s1.substring(2);
s1 = null;</code></pre>
<ul>
<li><strong>引用类型</strong> 与 <strong>原始值包装类型</strong> 的主要区别在于对象的生命周期. 在通过 <code>new</code> 实例化引用类型后，得到的实例会在离开作用域时被销毁</li>
<li>而自动创建的原始包装对象则只存在于访问它的那行代码执行期间。这意味着不能在运行时给原始值添加属性和方法</li>
<li>可以显示地使用 Boolean、Number、String 构造函数创建原始包装对象，不过应该在确实必要时再这么做，否则容易让开发者疑惑，分不清它们到底是原始值还是原始包装对象
<ul>
<li>在原始值包装类型的实例上调用 typeof 会返回 “object”</li>
<li>所有原始值包装对象都会转换为布尔值</li>
</ul></li>
</ul>
<pre class="js"><code>let s1 = &quot;some text&quot;;
s1.color = &quot;red&quot;;
console.log(s1.color); // undefined</code></pre>
<ul>
<li>Object 构造函数作为一个工厂方法，能够根据传入值的类型返回相应的原始包装类型的实例</li>
</ul>
<pre class="js"><code>let obj_string = new Object(&quot;some text&quot;);
console.log(obj_string instanceof String); // true

let obj_number = new Object(1);
console.log(obj_number instanceof Number); // true

let obj_boolean = new Object(true);
console.log(obj_boolean instanceof Boolean); // true</code></pre>
<ul>
<li>使用 new 调用原始值包装类型的构造函数，与调用同名的转型函数并不一样</li>
</ul>
<pre class="js"><code>let value = &quot;25&quot;;

let number = Number(value); // 转型函数, 变量 number 中保存的是一个值为 25 的原始数值
console.log(typeof number); // &quot;number&quot;

let obj = new Number(value); // 构造函数, 变量 obj 中保存的是一个 Number 的实例
console.log(typeof obj);     // object</code></pre>
<ul>
<li>虽然不推荐显式创建原始值包装类型的实例，但他们对于操作原始值的功能是很重要的。每个原始值包装类型都有相应的一套方法来方便数据操作</li>
</ul>
<div id="boolean" class="section level3">
<h3>3.1 Boolean</h3>
<ul>
<li>Boolean 是对应布尔值的引用类型
<ul>
<li>要创建一个 Boolean 对象，就使用 <code>Boolean 构造函数</code> 并传入 <code>true</code> 或 <code>false</code></li>
</ul></li>
</ul>
<pre class="js"><code>let booleanObject = new Boolean(true);</code></pre>
<ul>
<li>Boolean 的实例会重写 valueOf() 方法，返回一个原始值 <code>true</code> 或 <code>false</code></li>
</ul>
<pre class="js"><code>let booleanObject = new Boolean(true);
console.log(booleanObject.valueOf()); // ture

let trueValue = true;
console.log(trueValue.valueOf()); // ture</code></pre>
<ul>
<li>toString() 方法被调用时也会被覆盖，返回字符串 <code>"true"</code> 或 <code>"false"</code></li>
</ul>
<pre class="js"><code>let booleanObject = new Boolean(true); 
console.log(booleanObject.toString()); // &quot;true&quot;

let trueValue = true;
console.log(trueValue.toString()); // &quot;true&quot;</code></pre>
<ul>
<li><p>Boolean 原始值(<code>let falseValue = fasle;</code>)与引用值(<code>let falseObject = new Boolean(fasle);</code>)有几个区别：</p>
<ol style="list-style-type: decimal">
<li><code>typeof</code> 操作符对原始值返回 <code>"boolean"</code>，对引用值返回 <code>"object"</code></li>
</ol>
<pre class="js"><code>let falseObject = new Boolean(false); // Boolean 对象
// 布尔运算中 false &amp;&amp; true 应该等于 false
// 可是这个表达式是对 falseObject 对象而不是对它表示的值(false)求值
// 因为所有对象在布尔表达式中都会自动转换为 true，因此 falseObject 在这个表达式里实际上表示一个 true 值，那么 true &amp;&amp; true 是 true
let result1 = falseObject &amp;&amp; true; 
console.log(result1); // true

let falseValue = false;
let result2 = falseValue &amp;&amp; true;
console.log(result2); // false</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>Boolean 对象是 Boolean 类型的实例，在使用 instanceof 操作符时返回 true，但对原始值则返回 false</li>
</ol>
<pre class="js"><code>console.log(typeof flaseObject); // object
console.log(typeof falseValue); // boolean
console.log(falseObject instanceof Boolean); // true
console.log(falseValue instanceof Boolean); // false</code></pre></li>
<li><p>理解原始布尔值(<code>false</code>)和 Boolean 对象(<code>new Boolean(true/false)</code>)之间的区别非常重要，强烈建议永远不要使用后者</p></li>
</ul>
</div>
<div id="number" class="section level3">
<h3>3.2 Number</h3>
<ul>
<li>Number 是对应数值的引用类型
<ul>
<li>要创建一个 Number 对象，就使用 <code>Number 构造函数</code>并传入一个<code>数值</code></li>
</ul></li>
</ul>
<pre class="js"><code>let numberObject = new Number(10);</code></pre>
<ul>
<li><p>Number 类型重写了 valueOf()、toLocaleString()、toString() 等从 Object 继承的方法</p>
<ul>
<li>valueOf 方法返回 Number 对象表示的原始值</li>
</ul>
<pre class="js"><code>let num = 10;
console.log(num.valueOf()); // 10

let numberObject = new Number(10);
console.log(numberObject.valueOf()); // 10</code></pre>
<ul>
<li>toLocaleString() 方法返回数值字符串</li>
</ul>
<pre class="js"><code>let num = 10;
console.log(num.toLocalString()); // &quot;10&quot;

let numberObject = new Number(10);
console.log(numberObject.toLocalString()); // &quot;10&quot;</code></pre>
<ul>
<li>toString() 方法返回数值字符串，并且可以选择地接收一个表示基数的参数，并返回相应基数形式的数值字符串</li>
</ul>
<pre class="js"><code>let num = 10;
console.log(num.toString()); // &quot;10&quot;
console.log(num.toString(2)); // &quot;1010&quot;
console.log(num.toString(8)); // &quot;12&quot;
console.log(num.toString(10)); // &quot;10&quot;
console.log(num.toString(16)); // &quot;a&quot;

let numberObject = new Number(10);
console.log(numberObject.toString()); // &quot;10&quot;
console.log(numberObject.toString(2)); // &quot;1010&quot;
console.log(numberObject.toString(8)); // &quot;12&quot;
console.log(numberObject.toString(10)); // &quot;10&quot;
console.log(numberObject.toString(16)); // &quot;a&quot;</code></pre></li>
<li><p>Number 类型提供了几个用于将数值格式化为字符串的方法</p>
<ul>
<li><code>toFixed()</code>返回包含指定小数点位数的数值字符串，如果数值超过了参数指定的位数，则四舍五入到最近的小数位</li>
</ul>
<pre class="js"><code>let num = 10;
console.log(num.toFixed(2)); // &quot;10.00&quot;

let num = 10.005;
console.log(num.toFixed(2)); // &quot;10.01&quot;</code></pre>
<ul>
<li><code>toExponential()</code>返回以科学计数法(也称指数计数法)表示的数值字符串</li>
</ul>
<pre class="js"><code>let num = 10;
console.log(num.toExponential(1)); // &quot;1.0e+1&quot;</code></pre>
<ul>
<li><code>toPrecision()</code>：会根据情况返回最合理的输出结果，可能是固定精度，也可能是科学计数法形式</li>
</ul>
<pre class="js"><code>let num = 99;
console.log(num.toPrecision(1)); // &quot;1e+2&quot;
console.log(num.toPrecision(2)); // &quot;99&quot;
console.log(num.toPrecision(3)); // &quot;99.0&quot;</code></pre></li>
<li><p>与 Boolean 对象类似，Number 对象也为数值提供了重要能力。但是，考虑到两者存在同样的潜在 问题，因此并不建议直接实例化 Number 对象</p></li>
</ul>
<pre class="js"><code>let numberObject = new Number(10);
let numberValue = 10;
console.log(typeof numberObject);   // &quot;object&quot;
console.log(typeof numberValue);    // &quot;number&quot;
console.log(numberObject instanceof Number); // ture
console.log(numberObject instanceof Number); // false</code></pre>
<ul>
<li><code>Number.isInteger()</code> 方法
<ul>
<li>ES6 新增了 Number.isInteger() 方法，用于辨别一个数值是否保存整数。有时候，小数位的 0 可能会让人误以为数值是一个浮点数</li>
</ul></li>
</ul>
<pre class="js"><code>console.log(Number.isInteger(1));    // true
console.log(Number.isInteger(1.00)); // true
console.log(Number.isInteger(1.01)); // false</code></pre>
<ul>
<li><code>Number.isSafeInteger()</code> 方法
<ul>
<li>IEEE 754 数值格式有一个特殊的数值范围，在这个范围内二进制数值可以表示一个整数值</li>
<li>数值范围从 <code>Number.MIN_SAFE_INTEGER</code>(<span class="math inline">\(-2^{53}+1\)</span>) 到 <code>Number.MAX_SAFE_INTEGER</code>(<span class="math inline">\(2^{52}-1\)</span>)</li>
<li>对超出这个范围的数值，即使尝试保存为整数，IEEE 754 编码格式也意味着二进制值会表示一个完全不同的数值</li>
<li>为了鉴别一个整数是否在这个范围内，可以使用 Number.isSafeInteger() 方法</li>
</ul></li>
</ul>
<pre class="js"><code>console.log(Number.isSafeInteger(-1 * (2 ** 53)));     //false
console.log(Number.isSafeInteger(-1 * (2 ** 53) + 1)); // ture
console.log(Number.isSafeInteger(2 ** 53));            // false
console.log(Number.isSafeInteger((2 ** 53) - 1));      // true</code></pre>
</div>
<div id="string" class="section level3">
<h3>3.3 String</h3>
<ul>
<li>String 是对应字符串的引用类型
<ul>
<li>要创建一个 String 对象，就使用 String 构造函数并传入一个数值</li>
</ul></li>
</ul>
<pre class="js"><code>let stringObject = new String(&quot;hello world&quot;);</code></pre>
<ul>
<li>String 对象的方法可以在所有字符串原始值上调用。下面三个继承的方法都返回对象的原始字符串值：
<ul>
<li>valueOf()</li>
<li>toLocaleString()</li>
<li>toString()</li>
</ul></li>
</ul>
<pre class="js"><code>let stringValue = &quot;hello world&quot;;
console.log(stringObject.valueOf()); // &quot;hello world&quot;
console.log(stringObject.toLocaleString()); // &quot;hello world&quot;
console.log(stringObject.toString()); // &quot;hello world&quot;</code></pre>
<ul>
<li>String 对象都有一个 <code>length</code> 属性，表示字符串中字符的数量</li>
</ul>
<pre class="js"><code>let stringValue = &quot;hello world&quot;;
console.log(stringValue.length); // &quot;11&quot;</code></pre>
<ul>
<li>String 类型提供了很多方法来解析和操作字符串</li>
</ul>
<div id="javascript-字符" class="section level4">
<h4>3.3.1 JavaScript 字符</h4>
<ul>
<li>JavaScript 字符串由 16 位码元(code unit)组成。对多数字符来说，每 16 位码元对应一个字符</li>
<li>字符串的 length 属性表示字符串包含多少 16 位码元</li>
</ul>
<pre class="js"><code>let message = &quot;abcde&quot;;
console.log(message.length); // 5</code></pre>
<ul>
<li><code>charAt()</code> 方法返回给定索引位置的字符</li>
</ul>
<pre class="js"><code>let message = &quot;abcde&quot;;
console.log(message.charAt(2)); // &quot;c&quot;</code></pre>
<ul>
<li>JavaScript 字符串使用了两种 Unicode 编码混合的策略：UCS-2 和 UTF-16。对于可以采用 16位编码的字符(U+0000~U+FFFF)，这两种编码实际上是一样的</li>
<li><code>charCodeAt()</code> 方法可以查看指定码元的字符编码</li>
</ul>
<pre class="js"><code>let message = &quot;abcde&quot;;
// Unicode &quot;Latin small letter C&quot; 的编码是 U+0063
console.log(message.charCodeAt(2)); // 99

// 十进制 99 等于十六进制 63
console.log(99 === 0x63); // true</code></pre>
</div>
<div id="normalize-方法" class="section level4">
<h4>3.3.2 normalize() 方法</h4>
<p>#TODO</p>
</div>
<div id="字符串操作方法" class="section level4">
<h4>3.3.3 字符串操作方法</h4>
<ul>
<li><p>字符串拼接</p>
<ul>
<li><code>concat()</code>：将一个或多个字符串拼接成一个新字符串</li>
</ul>
<pre class="js"><code>let stringValue = &quot;hello&quot;;
let result = stringValue.concat(&quot; world&quot;);
console.log(result); // &quot;hello world&quot;
console.log(stringValue); // &quot;hello&quot;</code></pre>
<pre class="js"><code>let stringValue = &quot;hello&quot;;
let result = stringValue.concat(&quot; &quot;, &quot;world&quot;, &quot;!&quot;);
console.log(result); // &quot;hello world!&quot;
console.log(stringValue); // &quot;hello&quot;</code></pre>
<ul>
<li><code>+</code>：更常用</li>
</ul>
<pre class="js"><code>let result = stringValue + &quot; &quot; + &quot;world&quot; + &quot;!&quot;;
console.log(result);</code></pre></li>
<li><p>字符串提取</p>
<ul>
<li><code>slice(start[, end])</code></li>
<li><code>substr(start[, end])</code></li>
<li><code>substring(start[, num])</code></li>
</ul>
<pre class="js"><code>let stringValue = &quot;hello world&quot;;
console.log(stringValue.slice(3));          // &quot;lo world&quot;
console.log(stringValue.substring(3));      // &quot;lo world&quot;
console.log(stringValue.substr(3));         // &quot;lo world&quot;
console.log(stringValue.slice(3, 7));       // &quot;lo w&quot;
console.log(stringValue.substring(3, 7));   // &quot;low w&quot;
console.log(stringValue.substr(3, 7));      // &quot;lo worl&quot;
// slice 方法将所有负值参数都当成字符串长度加上负参数
console.log(stringValue.slice(-3));        // &quot;rld&quot;
console.log(stringValue.slice(stringValue.length + (-3)));// substring 方法将所有福参数值都转换为0
console.log(stringValue.substring(-3));    // &quot;hello world&quot;
// substr 方法将第一个负参数值当成字符串长度加上改值
console.log(stringValue.substr(-3));       // &quot;rld&quot;
console.log(stringValue.slice(3, -4));     // &quot;lo w&quot;
console.log(stringValue.substring(3, -4)); // &quot;hel&quot;
console.log(stringValue.substr(3, -4));    // &quot;&quot; (empty string)</code></pre></li>
</ul>
</div>
<div id="字符串位置方法" class="section level4">
<h4>3.3.4 字符串位置方法</h4>
<ul>
<li><code>indexOf()</code></li>
<li><code>lastIndexOf()</code></li>
</ul>
<pre class="js"><code>let stringValue = &quot;hello world&quot;;
console.log(stringValue.indexOf(&quot;o&quot;));     // 4
console.log(stringValue.lastIndexOf(&quot;o&quot;)); // 7
console.log(stringValue.indexOf(&quot;o&quot;, 6));     // 7
console.log(stringValue.lastIndexOf(&quot;o&quot;, 6)); // 4
let stringValue = &quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit&quot;;
let positions = new Array();
let pos = stringValue.indexOf(&quot;e&quot;);while(pos &gt; -1) {    
    positions.push(pos);    
    pos = stringValue.indexOf(&quot;e&quot;, pos + 1);
} // [3, 24, 32, 35, 52]</code></pre>
</div>
<div id="字符串包含方法" class="section level4">
<h4>3.3.5 字符串包含方法</h4>
<ul>
<li><p>ECMAScript 6 增加了 3 个用于判断字符串中是否包含另一个字符的方法</p>
<ul>
<li><p><code>startsWith()</code></p>
<ul>
<li>检查开始索引 0 的匹配项</li>
<li>可接受可选的第二个参数，表示开始搜索的位置，如果传入第二个参数，则意味着这两个方法会从指定位置向着字符串末尾搜索，忽略该位置之前的所有字符</li>
</ul>
<pre class="js"><code>let message = &quot;foobarbaz&quot;;

console.log(message.startsWith(&quot;foo&quot;)); // true
console.log(message.startsWith(&quot;foo&quot;, 1)); // false</code></pre></li>
<li><p><code>endsWith()</code></p>
<ul>
<li>检索开始于索引(string.length - substring.length)的匹配项</li>
<li>可接受可选的第二个参数，表示应该当作字符串末尾的位置，如果不提供这个参数，那么默认就是字符串长度。如果提供这个参数，那么就好像字符串只有那么多字符串一样</li>
</ul>
<pre class="js"><code>let message = &quot;foobarbaz&quot;;

console.log(message.endsWith(&quot;bar&quot;)); // false
console.log(message.endsWith(&quot;bar&quot;, 6)); // true</code></pre></li>
<li><p><code>includes()</code></p>
<ul>
<li>检查整个字符串</li>
<li>可接受可选的第二个参数，表示开始搜索的位置，如果传入第二个参数，则意味着这两个方法会从指定位置向着字符串末尾搜索，忽略该位置之前的所有字符</li>
</ul>
<pre class="js"><code>let message = &quot;foobarbaz&quot;;

console.log(message.includes(&quot;bar&quot;)); // true
console.log(message.includes(&quot;bar&quot;, 4)); // false</code></pre></li>
</ul></li>
</ul>
<pre class="js"><code>let message = &quot;foobarbaz&quot;;

console.log(message.startsWith(&quot;foo&quot;)); // true
console.log(message.startsWith(&quot;bar&quot;)); // false

console.log(message.endsWith(&quot;baz&quot;)); // true
console.log(message.endsWith(&quot;bar&quot;)); // false

console.log(message.includes(&quot;bar&quot;)); // true
console.log(message.includes(&quot;qux&quot;)); // false</code></pre>
</div>
<div id="trim-方法" class="section level4">
<h4>3.3.6 trim() 方法</h4>
<ul>
<li>ECMAScript 在所有字符串上都提供了 <code>trim()</code> 方法，这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果
<ul>
<li><code>trimLeft()</code></li>
<li><code>trimRight()</code></li>
</ul></li>
</ul>
<pre class="js"><code>let stringValue = &quot;  hello world &quot;;
let trimmedStringValue = stringValue.trim();

console.log(stringValue); // &quot;  hello world &quot;
console.log(trimmedStringValue); // &quot;hello world&quot;</code></pre>
</div>
<div id="repeat-方法" class="section level4">
<h4>3.3.7 repeat() 方法</h4>
<ul>
<li>ECMAScript 在所有字符串上都提供了 <code>repeat()</code> 方法，这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果</li>
</ul>
<pre class="js"><code>let stringValue = &quot;na &quot;;
console.log(stringValue.repeat(16) + &quot;batman&quot;);
// na na na na na na na na na na na na na na na na batman</code></pre>
</div>
<div id="padstart-和-padend-方法" class="section level4">
<h4>3.3.8 padStart() 和 padEnd() 方法</h4>
<ul>
<li><p><code>padStart()</code> 和 <code>padEnd()</code> 方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。</p>
<ul>
<li>这两个方法的第一个参数是长度，第二个 参数是可选的填充字符串，默认为空格(U+0020)</li>
</ul>
<pre class="js"><code>let stringValue = &quot;foo&quot;;

console.log(stringValue.padStart(6)); // &quot;   foo&quot;
console.log(stringValue.padStart(9, &quot;.&quot;)); // &quot;......foo&quot;

console.log(stringValue.padEnd(6)); // &quot;foo   &quot;
console.log(stringValue.padEnd(9, &quot;.&quot;)); // &quot;foo......&quot;</code></pre>
<ul>
<li>可选的第二个参数并不限于一个字符，如果提供了多个字符的字符串，则会将其拼接并截断以匹配指定长度</li>
<li>此外，如果长度小于或等于字符串长度，则会返回原始字符串</li>
</ul>
<pre class="js"><code>let stringValue = &quot;foo&quot;;

console.log(stringValue.padStart(8, &quot;bar&quot;)); // &quot;barbafoo&quot;
console.log(stringValue.padStart(2)); // &quot;foo&quot;

console.log(stringValue.padEnd(8, &quot;bar&quot;)); // &quot;foobarba&quot;
console.log(stringValue.padEnd(2)); // &quot;foo&quot;</code></pre></li>
</ul>
</div>
<div id="字符串迭代与解构" class="section level4">
<h4>3.3.9 字符串迭代与解构</h4>
<ul>
<li>字符串的原型上暴露了一个 <code>@@iterator</code> 方法，表示可以迭代字符串的每个字符</li>
</ul>
<pre class="js"><code>let message = &quot;abc&quot;;
let stringIterator = message[Symbol.iterator]();

console.log(stringIterator.next()); // {value: &quot;a&quot;, done: false}
console.log(stringIterator.next()); // {value: &quot;b&quot;, done: false}
console.log(stringIterator.next()); // {value: &quot;c&quot;, done: false}
console.log(stringIterator.next()); // {value: undefined, done: true}</code></pre>
<ul>
<li>在 <code>for-of</code> 循环中可以通过这个迭代器按序访问每个字符</li>
</ul>
<pre class="js"><code>for (const c of &quot;abcde&quot;) {
    console.log(c);
}
// a
// b
// c
// d
// e</code></pre>
<ul>
<li>有了这个迭代器后，字符串就可以通过解构操作来结构了</li>
</ul>
<pre class="js"><code>let message = &quot;abcde&quot;;
console.log([...message]); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</code></pre>
</div>
<div id="字符串大小写转换" class="section level4">
<h4>3.3.10 字符串大小写转换</h4>
<ul>
<li><code>toLowerCase()</code></li>
<li><code>toLocaleLowerCase()</code>
<ul>
<li>基于特定地区的实现，在少数语言中(如土耳其语)，Unicode 大小写转换需应用特殊规则</li>
</ul></li>
<li><code>toUpperCase()</code></li>
<li><code>toLocaleUpperCase()</code>
<ul>
<li>基于特定地区的实现，在少数语言中(如土耳其语)，Unicode 大小写转换需应用特殊规则</li>
</ul></li>
<li>如果不知道代码设计什么语言，则最好使用地区特定的转换方法</li>
</ul>
</div>
<div id="字符串模式匹配方法" class="section level4">
<h4>3.3.11 字符串模式匹配方法</h4>
<ul>
<li><p>String 类型专门在为字符串中实现模式匹配设计了几个方法</p>
<ul>
<li><code>match(正则表达式字符串 or RegExp对象)</code>
<ul>
<li>本质上跟 RegExp 对象的 exec() 方法相同</li>
</ul></li>
</ul>
<pre class="js"><code>let text = &quot;cat, bat, sat, fat&quot;;
let pattern = /.at/;

// 等价于 pattern.exec(text)
let matches = text.match(pattern);
console.log(matches.index); // 0
console.log(matches[0]); // &quot;cat&quot;
console.log(matches.lastIndex); // 0</code></pre>
<ul>
<li><code>search(正则表达式字符串 or RegExp对象)</code></li>
</ul>
<pre class="js"><code>let text = &quot;cat, bat, sat, fat&quot;;
let pattern = /at/;
let pos = text.search(pattern);
console.log(pos); // 1</code></pre>
<ul>
<li><code>replace(RegExp对象 or 字符串, 字符串 or 函数)</code>
<ul>
<li>如果第一个参数是字符串，那么只会替换第一个字符串</li>
<li>想要替换素有字符串，第一个参数必须为正则表达式并且带全局标记<code>/g</code></li>
</ul></li>
</ul>
<pre class="js"><code>let text = &quot;cat, bat, sat, fat&quot;;
let result = text.replace(&quot;at&quot;, &quot;ond&quot;);
console.log(result); // &quot;cond, bat, sat, fat&quot;

result = text.replace(/at/g, &quot;ond&quot;);
console.log(result); // &quot;cond, bond, sond, fond&quot;</code></pre>
<p>TOOD</p>
<ul>
<li>split()</li>
</ul></li>
</ul>
</div>
<div id="localecompare-方法" class="section level4">
<h4>3.3.12 localeCompare() 方法</h4>
<ul>
<li>localeCompare() 方法比较两个字符串，返回如下 3 个值中的一个
<ul>
<li>如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负值
<ul>
<li>通常是 -1，具体还要看与实际值相关的实现</li>
</ul></li>
<li>如果字符串与字符串参数相等，则返回 0</li>
<li>如果按照字母表顺序，字符串应该排在字符串参数后头，则返回正值
<ul>
<li>通常是 1，具体还要看与实际值相关的实现</li>
</ul></li>
</ul></li>
<li>示例 1</li>
</ul>
<pre class="js"><code>let stringValue = &quot;yellow&quot;;

console.log(stringValue.localCompare(&quot;brick&quot;)); // 1
console.log(stringValue.localCompare(&quot;yellow&quot;)); // 0
console.log(stringValue.localCompare(&quot;zoo&quot;)); // -1</code></pre>
<ul>
<li>示例 2：因为返回的具体值可能因具体实现而异，所以这样使用 localeCompare() 方法
<ul>
<li>localeCompare() 的独特之处在于，实现所在的地区(国家和语言)决定了这个方法如何比较字符串，在美国，英语 ECMAScript 实现的标准语言，localeCompare() 区分大小写，大写字母排在小写字母前面，但其他地区未必是这种情况</li>
</ul></li>
</ul>
<pre class="js"><code>function determineOrder(value) {
    let result = stringValue.localeCompare(value);
    if (result &lt; 0) {
        console.log(`The string &#39;yellow&#39; comes before the string &#39;${value}&#39;.`);
    } else if (result &gt; 0) {
        console.log(`The string &#39;yellow&#39; comes after the string &#39;${value}&#39;.`);
    } else {
        console.log(`The string &#39;yellow&#39; is equal the string &#39;${value}&#39;.`);
    }
}

determineOrder(&quot;brick&quot;);
determineOrder(&quot;yellow&quot;);
determineOrder(&quot;zoo&quot;);</code></pre>
</div>
<div id="html-方法" class="section level4">
<h4>3.3.13 HTML 方法</h4>
<ul>
<li>早期的浏览器开发商认为使用 JavaScript 动态生成 HTML 标签是一个需求。因此，早期浏览器扩展了规范，增加了生成 HTML 标签的方法。不过，这些方法基本上已经没有人使用了，因为结果通常不是语义化的标记</li>
</ul>
</div>
</div>
</div>
<div id="单例内置对象" class="section level2">
<h2>4.单例内置对象</h2>
<ul>
<li>ECMA-262 对内置对象的定义是：
<ul>
<li><strong>任何由 ECMAScript 实现提供、与宿主环境无关，并在 ECMAScript 程序开始执行时就存在的对象</strong></li>
</ul></li>
<li>这意味着，开发者不用显示地实例化内置对象，因为它们已经实例化好了</li>
<li>常见的内置对象：
<ul>
<li>Object</li>
<li>Array</li>
<li>String</li>
<li>Global</li>
<li>Math</li>
</ul></li>
</ul>
<div id="global" class="section level3">
<h3>4.1 Global</h3>
<ul>
<li>Global 对象是 ECMAScript 中最特别的对象，因为代码不会显式地访问它</li>
<li>ECMA-262 规定 Global 对象是一种兜底对象，它针对的是不属于任何对象的属性和方法</li>
<li>事实上，不存在全局变量或全局函数这种东西，在全局作用域中定义的变量和函数都会变成 Global 对象的属性，下面的函数都是 Global 对象的方法:
<ul>
<li>isNaN()</li>
<li>isFinite()</li>
<li>parseInt()</li>
<li>parseFloat()</li>
<li>encodeURI()</li>
<li>encodeURIComponent()</li>
<li>decodeURI()</li>
<li>decodeURIComponent()</li>
<li>eval()</li>
</ul></li>
</ul>
<div id="url-编码方法" class="section level4">
<h4>4.1.1 URL 编码方法</h4>
<ul>
<li><p><code>encodeURI()</code> 和 <code>encodeURIComponent()</code> 方法用于编码统一资源标识符(URI)，以便传给浏览器，有效的 URI 不能包含某些字符，比如空格。使用 URI 编码方法来编码 URI 可以让浏览器能够理解它们，同时又以特殊的 UTF-8 编码替换掉所有无效字符</p></li>
<li><p><code>encodeURI()</code> 方法用于对整个 URI 进行编码</p>
<ul>
<li>比如: <code>"www.wrox.com/illegal value.js"</code></li>
</ul></li>
<li><p><code>encodeURIComponent()</code> 方法用于编码 URI 中单独的组件，</p>
<ul>
<li><code>"illegal value.js"</code></li>
</ul></li>
<li><p><code>encodeURI()</code> 方法与 <code>encodeURIComponent()</code> 的主要区别是，<code>encodeURI()</code> 不会编码属于 URL 组件的特殊字符，比如 冒号、斜杆、问号、井号，而 <code>encodeURIComponent()</code> 会编码它发现的素有非标准字符</p>
<pre class="js"><code>let uri = &quot;http://www.wrox.com/illegal value.js#start&quot;;

// &quot;http://www.wrox.com/illegal%20value.js#start&quot;
console.log(encodeURI(uri));

// &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start&quot;
console.log(encodeURIComponent(uri));</code></pre></li>
<li><p>与 <code>encodeURI()</code> 和 <code>encodeURIComponent()</code> 相对的是 <code>decodeURI()</code> 和 <code>decodeURIComponent()</code></p>
<pre class="js"><code>let uri = &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start&quot;;

// &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal value.js%23start&quot;
console.log(decodeURI(uri));

// &quot;http://www.wrox.com/illegal value.js#start&quot;
console.log(decodeURIComponent(uri));</code></pre></li>
</ul>
</div>
<div id="eval-方法" class="section level4">
<h4>4.1.2 eval() 方法</h4>
<ul>
<li><p><code>eval()</code> 可能是 ECMAScript 语言中最强大的方法了，这个方法就是一个完整的 ECMAScript 解释器，它接受一个参数，即一个要执行的 ECMAScript(JavaScript)字符串。当解释器发现 <code>eval()</code> 调用时，会将参数解释为实际的 ECMAScript 语句，然后将其插入到该位置</p></li>
<li><p>示例</p></li>
</ul>
<pre class="js"><code>eval(&quot;console.log(&#39;hi&#39;)&quot;);

// 等价于

console.log(&quot;hi&quot;);</code></pre>
<ul>
<li>通过 <code>eval()</code> 执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链，这意味着定义在包含上下文中的变量可以在 <code>eval()</code> 调用内部被引用</li>
</ul>
<pre class="js"><code>let msg = &quot;hello world&quot;;
eval(&quot;console.log(msg)&quot;); // &quot;hello world&quot;</code></pre>
<ul>
<li>可以在 <code>eval()</code> 内部定义一个函数或变量，然后在外部代码中引用</li>
</ul>
<pre class="js"><code>eval(&quot;function sayHi() { console.log(&#39;hi&#39;); }&quot;);
sayHi();</code></pre>
<ul>
<li>通过 <code>eval()</code> 定义的任何变量和函数都不会被提升，这是因为在解析代码的时候，它们是被包含在一个字符串中的。它们只是在 <code>eval()</code> 执行的时候才会被创建</li>
</ul>
<pre class="js"><code>eval(&quot;let msg = &#39;hello world&#39;;&quot;);
console.log(msg); // Reference Error: msg is not defined</code></pre>
<ul>
<li>在严格模式下，在 <code>eval()</code> 内部创建的变量和函数无法被外部访问</li>
<li>在严格模式下，赋值给 <code>eval</code> 也会导致错误</li>
</ul>
<pre class="js"><code>&quot;use strict&quot;;
eval = &quot;hi&quot;; // 导致错误</code></pre>
</div>
<div id="global-对象属性" class="section level4">
<h4>4.1.3 Global 对象属性</h4>
<ul>
<li>Global 对象有很多属性</li>
</ul>
<table>
<thead>
<tr class="header">
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>undefined</td>
<td>特殊值 undefined</td>
</tr>
<tr class="even">
<td>NaN</td>
<td>特殊值 NaN</td>
</tr>
<tr class="odd">
<td>Infinity</td>
<td>特殊值 Infinity</td>
</tr>
<tr class="even">
<td>Object</td>
<td>Object 的构造函数</td>
</tr>
<tr class="odd">
<td>Array</td>
<td>Array 的构造函数</td>
</tr>
<tr class="even">
<td>Function</td>
<td>Function 的构造函数</td>
</tr>
<tr class="odd">
<td>Boolean</td>
<td>Boolean 的构造函数</td>
</tr>
<tr class="even">
<td>String</td>
<td>String 的构造函数</td>
</tr>
<tr class="odd">
<td>Number</td>
<td>Number 的构造函数</td>
</tr>
<tr class="even">
<td>Date</td>
<td>Date 的构造函数</td>
</tr>
<tr class="odd">
<td>RegExp</td>
<td>RegExp 的构造函数</td>
</tr>
<tr class="even">
<td>Symbol</td>
<td>Symbol 的构造函数</td>
</tr>
<tr class="odd">
<td>Error</td>
<td>Error 的构造函数</td>
</tr>
<tr class="even">
<td>EvalError</td>
<td>EvalError 的构造函数</td>
</tr>
<tr class="odd">
<td>RangeError</td>
<td>RangeError 的构造函数</td>
</tr>
<tr class="even">
<td>ReferenceError</td>
<td>Reference 的构造函数</td>
</tr>
<tr class="odd">
<td>SyntaxError</td>
<td>SyntaxError 的构造函数</td>
</tr>
<tr class="even">
<td>TypeError</td>
<td>TypeError 的构造函数</td>
</tr>
<tr class="odd">
<td>URIError</td>
<td>URIError 的构造函数</td>
</tr>
</tbody>
</table>
</div>
<div id="window-对象" class="section level4">
<h4>4.1.4 window 对象</h4>
<ul>
<li>虽然 ECMA-262 没有规定直接访问 Global 对象的方式，但浏览器将 <code>window</code> 对象实现为 <code>Global</code> 对象的代理。因此，所有全局作用域中声明的变量和函数都变成了 <code>window</code> 的属性</li>
</ul>
<pre class="js"><code>var color = &quot;red&quot;;

function sayColor() {
    console.log(window.color);
}
window.sayColor(); // &quot;red&quot;</code></pre>
<ul>
<li>当一个函数在没有明确(通过成为某个对象的方法，或者通过 <code>call()</code>/<code>apply()</code>)指定 <code>this</code> 值的情况下执行时，<code>this</code> 值等于 <code>Global</code> 对象，因此，调用一个简单返回 <code>this</code> 的函数是在任何执行上下文中获取 <code>Global</code> 对象的通用方式</li>
</ul>
<pre class="js"><code>let global = function() {
    return this;
}();</code></pre>
</div>
</div>
<div id="math" class="section level3">
<h3>4.2 Math</h3>
<ul>
<li>ECMAScript 提供了 Math 对象作为保存数学公式、信息和计算的地方</li>
<li>Math 对象提供了一些辅助计算的属性和方法</li>
</ul>
<div id="math-对象属性" class="section level4">
<h4>4.2.1 Math 对象属性</h4>
<ul>
<li>Math 对象有一些属性，主要用于保存数学中的一些特殊值</li>
</ul>
<p><img src="/Users/zfwang/Library/Application%20Support/typora-user-images/image-20210413213822194.png" alt="image-20210413213822194" style="zoom: 33%;" /></p>
</div>
<div id="math.min-和-math.max-方法" class="section level4">
<h4>4.2.2 Math.min() 和 Math.max() 方法</h4>
<ul>
<li>多个参数取值</li>
</ul>
<pre class="js"><code>let max = Math.max(3, 54, 32, 16);
console.log(max); // 54

let min = Math.min(3, 54, 32, 16);
console.log(min); // 3</code></pre>
<ul>
<li>数组取值</li>
</ul>
<pre class="js"><code>let values = [1, 2, 3, 4, 5, 6, 7, 8];
let max = Math.max(...values);
console.log(max); // 8</code></pre>
</div>
<div id="舍入方法" class="section level4">
<h4>4.2.3 舍入方法</h4>
<ul>
<li><code>Math.ceil()</code>
<ul>
<li>始终向上舍入为最近接的整数</li>
</ul></li>
<li><code>Math.floor()</code>
<ul>
<li>始终向下舍入为最接近的整数</li>
</ul></li>
<li><code>Math.round()</code>
<ul>
<li>执行四舍五入</li>
</ul></li>
<li><code>Math.fround()</code>
<ul>
<li>返回数值最接近的单精度(32)位浮点值表示</li>
</ul></li>
</ul>
</div>
<div id="math.random-方法" class="section level4">
<h4>4.2.4 Math.random() 方法</h4>
<ul>
<li><code>Math.random()</code> 方法返回一个 0~1 范围内的随机数，其中包含 0 但不包含 1
<ul>
<li>对于希望显示随机名言或随机新闻的网页，这个方法非常方便</li>
</ul></li>
</ul>
<pre class="js"><code>// 从一组整数中随机选择一个数
let num = Math.floor(Math.random() * total_number_of_choices + first_possible_value);

// 从 1~10 范围内随机选择一个数
let num = Math.floor(Math.random() * 10 + 1); // (0 ~ 0.99999999999999) * 10 = 0 ~ 9.9999999999 + 1 = 1 ~ 10.9999999999

// 从 2~10 范围内随机选择一个数
let num = Math.floor(Math.random() * 9 + 2); // (0 ~ 0.99999999999999) * 9 = 0 ~ 8.9999999991 + 2 = 2 ~ 10.9999999999

// -----------------------------------
// 通过函数来算出可选总数和最小可能的值
// -----------------------------------
function selectFrom(lowerValue, upperValue) {
    let choices = upperValue - lowerValue + 1;
    return Math.floor(Math.random() * choices + lowerValue);
}

// 从 2 ~ 10 范围内随机选择一个数
let num = selectFrom(2, 10);
console.log(num); // 2 ~ 10 范围的值，其中包含 2 和 10

// 从数组中随机选择一个元素
let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;purple&quot;, &quot;brown&quot;];
let color = colors[selectFrom(0, colors.length - 1)];
console.log(color);</code></pre>
<ul>
<li><code>Math.random()</code> 方法在这里出于演示目的是没有问题的。如果为了加密而需要生成随机数(传给生成器的输入需要较高的不确定性)，那么建议使用 <code>window.crypto.getRandomValues()</code></li>
</ul>
</div>
<div id="其他方法" class="section level4">
<h4>4.2.5 其他方法</h4>
<p><img src="/Users/zfwang/Library/Application%20Support/typora-user-images/image-20210413214548023.png" alt="image-20210413214548023" style="zoom:33%;" /></p>
</div>
</div>
</div>
