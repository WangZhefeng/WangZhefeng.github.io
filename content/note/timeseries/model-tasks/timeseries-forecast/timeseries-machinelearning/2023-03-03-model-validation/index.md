---
title: 时间序列交叉验证
author: 王哲峰
date: '2023-03-03'
slug: timeseries-model-cv
categories:
  - timeseries
tags:
  - model
---

<style>
details {
    border: 1px solid #aaa;
    border-radius: 4px;
    padding: .5em .5em 0;
}
summary {
    font-weight: bold;
    margin: -.5em -.5em 0;
    padding: .5em;
}
details[open] {
    padding: .5em;
}
details[open] summary {
    border-bottom: 1px solid #aaa;
    margin-bottom: .5em;
}
img {
    pointer-events: none;
}
</style>

<details><summary>目录</summary><p>

- [传统交叉验证](#传统交叉验证)
- [单时序嵌套交叉验证](#单时序嵌套交叉验证)
  - [预测后一半嵌套交叉验证](#预测后一半嵌套交叉验证)
  - [日间隔前向链接嵌套交叉验证](#日间隔前向链接嵌套交叉验证)
- [多时序嵌套交叉验证](#多时序嵌套交叉验证)
  - [常规嵌套交叉验证](#常规嵌套交叉验证)
  - [群体知情嵌套交叉验证](#群体知情嵌套交叉验证)
- [Hold Out](#hold-out)
  - [Hold Out 介绍](#hold-out-介绍)
  - [Hold Out 应用](#hold-out-应用)
- [K-Fold 交叉验证](#k-fold-交叉验证)
  - [K-Fold](#k-fold)
  - [Blocked K-Fold](#blocked-k-fold)
  - [hv-Blocked K-Fold](#hv-blocked-k-fold)
  - [改进的 K-Fold](#改进的-k-fold)
- [参考](#参考)
</p></details><p></p>

> * 嵌套检查验证(Nested Cross-Validation)

# 传统交叉验证

交叉验证（Cross Validation, CV）是一项很流行的技术，用于调节超参数，是一种具备鲁棒性的模型性能评价技术。
两种最常见的交叉验证方式分别是：

1. k 折交叉验证
2. hold-out 交叉验证

由于文献中术语的不同，本文中我们将明确定义交叉验证步骤：

1. 首先，将数据集分割为两个子集：训练集和测试集。如果有需要被调整的参数，我们将训练集分为训练子集和验证集
2. 模型在训练子集上进行训练，在验证集上将误差最小化的参数将最终被选择
3. 最后，模型使用所选的参数在整个训练集上进行训练，并且记录测试集上的误差

![img](images/cv.png)

> 图 1：hold-out 交叉验证的例子。数据被分为训练集和测试集。然后训练集进一步进行分割：
> 一部分用来调整参数（训练子集），另一部分用来验证模型（验证集）

# 单时序嵌套交叉验证

为什么时序数据的交叉验证会有所不同？在处理时序数据时，
不应该使用传统的交叉验证方法（如 k 折交叉验证），原因在下面分析

1. 时序依赖
    - 为了避免数据泄露，要特别注意时间序列数据的分割。为了准确地模拟我们现在所处、预测未来的真实预测环境（Tashman 2000），
      预测者必须保留用于拟合模型的事件之后发生的事件的数据。因此，对于时间序列数据而言，我们没有使用 k 折交叉验证，
      而是使用 hold-out 交叉验证，其中一个数据子集（按照时间顺序分割）被保留下来用于验证模型性能。
      例如，图 1 中的测试集数据在时间顺序上是位于训练数据之后的。类似地，验证集也在训练集之后
2. 任意选择测试集
    - 注意，图 1 中测试集的选择是相当随意的，这种选择也意味着测试集误差是在独立测试集上不太好的误差估计
    - 为了解决这个问题，使用了一种叫做 **嵌套交叉验证（Nested Cross-Validation）** 的方法。
      嵌套交叉验证包含一个用于误差估计的外循环，以及一个用于调参的内循环（如图 2 所示）。
      内循环所起的作用和之前谈到的一样：训练集被分割成一个训练子集和一个验证集，模型在训练子集上训练，
      然后选择在验证集上能够使误差最小化的参数。但是，现在我们增加了一个外循环，
      它将数据集分割成多个不同的训练集和测试集，为了计算模型误差的鲁棒估计，对每一次分割的误差求平均值。
      这样做是有优势的：嵌套交叉验证过程可以提供一个几近无偏的真实误差估计(Varma and Simon 2006)。

![img](images/nest_cv.png)
> 图 2： 嵌套交叉验证示例

下面推荐两种嵌套交叉验证的方法，来处理仅具有一个时间序列的数据：

## 预测后一半嵌套交叉验证

> Predict Second Half

![img](images/predict_second_half.png)

第一种方法预测后一半，这是嵌套交叉验证的基本情况，只有一次训练/测试分割。它的优势是这种方法易于实现；
然而，它仍然面临着任意选择测试集的局限性。前一半数据（按照时间分割的）作为训练集，后一半数据成为测试集。
验证集的大小可以根据给定问题的不同而变化（例如图 3 中的例子用一天的数据作为验证集），
但是保证验证集的时间顺序在训练子集后面是非常重要的








## 日间隔前向链接嵌套交叉验证

> Day Forward-Chaining

预测后一半嵌套交叉验证方法的一个缺陷是 hold-out 测试集的任意选择会导致在独立测试集上预测误差的有偏估计。
为了生成对模型预测误差的更好估计，一个常用的方法就是进行多次训练/测试分割，然后计算这些分割上的误差平均值。

![img](images/day_forward_chaining.png)

日间隔前向链接技术是一种基于前向链（Forward-Chaining）的方法（在文献中也被称为 rolling-origin evaluation（Tashman，2000）和 rolling-origin-recalibration evaluation（Bergmeir & Benitez，2012））。
利用这种方法，将每天的数据作为测试集，并将以前的所有数据分配到训练集中。例如，如果数据集有五天，
那么将生成三个不同的训练和测试分割，如图 4 所示。请注意，在本示例中，我们有三次拆分，
而不是五次拆分，因为我们需要确保至少有一天的训练和验证数据可用。该方法产生许多不同的训练/测试分割，
并且对每个分割上的误差求平均，以计算模型误差的鲁棒估计

注意，在这个例子中使用日前向链，但是也可以在每个数据点上进行迭代，而不是按天迭代（但这明显意味着更多的拆分）









# 多时序嵌套交叉验证

如何处理具有多个不同时间序列的数据集。同样，使用两种方法

## 常规嵌套交叉验证

常规嵌套交叉验证（regular nested cross-validation）的训练集／验证集／测试集分割基本思路和之前的描述是一样的。
唯一的变化是现在的分割包含了来自数据集中不同参与者的数据。如果有两个参与者 A 和 B，
那么训练集将包含来自参与者 A 的前半天的数据和来自参与者 B 的前半天的数据。同样，测试集将包含每个参与者的后半天数据

## 群体知情嵌套交叉验证

对于群体知情嵌套交叉验证方法而言，我们利用了不同参与者数据之间的独立性。
这使得我们打破严格的时间顺序，至少在个人数据之间（在个人数据内打破严格时序仍然是必要的）。
由于这种独立性，我们可以稍微修改常规嵌套交叉验证算法。
现在，测试集和验证集仅包含来自一个参与者（例如参与者 A）的数据，
并且数据集中所有其他参与者的所有数据都被允许存在于训练集中。

![img](images/five.png)

图 5 描述了这种方法是如何适用于群体知情的日前向链嵌套交叉验证的。
该图显示，参与者 A 第 18 天的数据是测试集（红色），之前三天是验证集（黄色），
训练集（绿色）包含参与者 A 的所有先前数据以及其他参与者（本例中为 B、C、D 和 E）的所有数据。
需要强调的一点是，由于其他参与者的时间序列的独立性，使用这些参与者的未来观测不会造成数据泄漏

> 评估性能对预测模型的开发至关重要。交叉验证是一种流行的技术，但是在处理时间序列时，
> 应该确保交叉验证处理了数据的时间依赖性质，要防止数据泄漏和获得可靠的性能估计。
> 在时序问题上，需要特别注意不能做随机分割，而需要在时间维度上做前后的分割，
> 以保证与实际预测应用时的情况一致
> 
> 对于方法的采用建议如下：
> 
> * 首选技术是蒙特卡洛交叉验证
> * 其次，时间序列分割(及其变体)是一个很好的选择
> * 如果时间序列数据较大，通常直接使用 Holdout，因为评估过程更快


最后，总结了不同嵌套交叉验证方法的优缺点，特别是独立测试集误差估计的计算时间和偏差。
分割的次数假定数据集包含 `$p$` 个参与者，以及每个参与者共有 `$d$` 天的数据

![img](images/zongjie.png)

# Hold Out

> Hold Out 验证，样本外验证

## Hold Out 介绍

Hold Out 是估计预测效果最简单的方法。工作原理是进行一次分割，该序列的第一部分数据集用于训练模型，
在保留的数据集中进行验证。一般情况下训练集的大小设置为总数据集的 `$70\%$`，如果时间序列数据集不大，
使用单个分割可能会导致不可靠的估计

![img](images/holdout.png)

## Hold Out 应用

可以使用 scikit-learn 中的 `train_test_split` 函数应用 Hold Out 验证

```python
from sklearn.model_selection import train_test_split

tts = train_test_split()
```

# K-Fold 交叉验证

## K-Fold

K-Fold 交叉验证是一种用于评估模型性能的流行技术。它的工作原理是变换观测数据，
并将它们分配给 K 个相等大小的折，然后每折都被用作验证而剩下的其他数据用作模型训练。
这种方法的主要优点是所有的观测数据都在某个时刻被用于验证，
但是整个过程是在观测是独立的假设下进行的，这对时间序列来说是不成立的，
所以最好选择一种尊重观察的时间顺序的交叉验证方法

但是在某些情况下，K-Fold 交叉验证对时间序列是有用的。
例如，当时间序列是平稳的或样本量很小时

![img](images/kfold.png)

## Blocked K-Fold

一些专门设计的技术用于扩展时间序列的 K-Fold 交叉验证。其中一种方法是阻塞 K-Fold 交叉验证。
这个过程与之前相似，但是没有了打乱的部分。观察的顺序在每个块内保持不变，但在它们之间的关系被打破了。
这种方法对于平稳时间序列是很方便的

![img](images/blocked_kfold.png)

## hv-Blocked K-Fold

可以尝试通过在两个样本之间引入间隔来增加训练和验证之间的独立性。
这就是一种称为 hv-Blocked K-Fold 交叉验证的方法

![img](images/hv_blocked_kfold.png)

## 改进的 K-Fold

改进的 K-Fold 交叉验证保留了过程中的打乱部分。但是它删除了接近验证样本的任何训练观察值

改进的 K-Fold 交叉验证依赖于创造间隙而不是阻塞。但是这种技术的主要问题是许多训练观察被删除了。
这可能会导致拟合不足的问题

![img](images/modified_kfold.png)


# 参考

* [时间序列分割方法的介绍和对比](https://mp.weixin.qq.com/s/JpZV2E102FU94_aj-b-sOA)
* [时间序列的蒙特卡罗交叉验证](https://mp.weixin.qq.com/s/n4Ghl67_-r_NN29Jd5E5SA)
* [时间序列交叉验证](https://lonepatient.top/2018/06/10/time-series-nested-cross-validation)
* [样本组织](https://mp.weixin.qq.com/s?__biz=Mzk0NDE5Nzg1Ng==&mid=2247492305&idx=1&sn=c4c9783ee3ab85a8f7a813e803f15177&chksm=c32afb5ef45d7248d539aca50cff13a840ff53bb2400166ea146256675b08b93419be3f8fadc&scene=21#wechat_redirect)
* [Cross validation of time series data](https://scikit-learn.org/stable/modules/cross_validation.html)
* [样本组织篇](https://mp.weixin.qq.com/s?__biz=Mzk0NDE5Nzg1Ng==&mid=2247492305&idx=1&sn=c4c9783ee3ab85a8f7a813e803f15177&chksm=c32afb5ef45d7248d539aca50cff13a840ff53bb2400166ea146256675b08b93419be3f8fadc&scene=21#wechat_redirect)

