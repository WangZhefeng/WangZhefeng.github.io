---
title: 第九章、代理与反射
author: 王哲峰
date: '2020-07-01'
slug: js-proxy
categories:
  - 前端
tags:
  - tool
output:
  blogdown::html_page:
    toc: true
    fig_width: 6
    dev: "svg"
---

<script src="{{< blogdown/postref >}}index_files/header-attrs/header-attrs.js"></script>

<div id="TOC">
<ul>
<li><a href="#第九章代理与反射">第九章、代理与反射</a>
<ul>
<li><a href="#代理基础">1.代理基础</a>
<ul>
<li><a href="#创建空代理">1.1 创建空代理</a></li>
<li><a href="#定义捕获器">1.2 定义捕获器</a></li>
<li><a href="#捕获器参数和反射-api">1.3 捕获器参数和反射 API</a></li>
<li><a href="#捕获器不变式">1.4 捕获器不变式</a></li>
<li><a href="#可撤销代理">1.5 可撤销代理</a></li>
<li><a href="#实用反射-api">1.6 实用反射 API</a></li>
<li><a href="#代理另一个代理">1.7 代理另一个代理</a></li>
<li><a href="#代理的问题与不足">1.8 代理的问题与不足</a></li>
</ul></li>
<li><a href="#代理捕获器与反射方法">2.代理捕获器与反射方法</a></li>
<li><a href="#代理模式">3.代理模式</a></li>
</ul></li>
</ul>
</div>

<div id="第九章代理与反射" class="section level1">
<h1>第九章、代理与反射</h1>
<ul>
<li>ECMAScript 6 新增的代理和反射为开发者提供了 <strong>拦截并向基本操作嵌入额外行为的能力</strong></li>
<li>具体地说，可以给<strong>目标对象</strong>定义一个关联的<strong>代理对象</strong>，而这个代理对象可以作为抽象的目标对象来使用</li>
<li>在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制</li>
</ul>
<div id="代理基础" class="section level2">
<h2>1.代理基础</h2>
<ul>
<li>代理是目标对象的抽象。从很多方面看，代理类似 C++指针，因为它可以 用作目标对象的替身，但又完全独立于目标对象。目标对象既可以直接被操作，也可以通过代理来操作。 但直接操作会绕过代理施予的行为</li>
</ul>
<div id="创建空代理" class="section level3">
<h3>1.1 创建空代理</h3>
<ul>
<li><p>最简单的代理是空代理，即除了作为一个抽象的目标对象，什么也不做</p></li>
<li><p>默认情况下，代理对象上执行的所有操作都会无障碍地传播到目标对象，因此，在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象</p></li>
<li><p>代理是使用 <code>Proxy</code> 构造函数创建的，这个构造函数接收两个参数：</p>
<ul>
<li>目标对象</li>
<li>处理程序对象</li>
</ul>
<blockquote>
<ul>
<li><p>缺少其中任何一个参数都会抛出 <code>TypeError</code></p></li>
<li><p>要创建空代理，可以传入一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标对象</p></li>
</ul>
</blockquote></li>
<li><p>示例</p></li>
</ul>
<pre class="js"><code>// 目标对象
const target = {
    id: &quot;target&quot;
};

// 处理程序对象
const handler = {};

// 创建空代理
const proxy = new Proxy(target, handler);

// id 属性会访问同一个值
console.log(target.id); // target
console.log(proxy.id); // target

// 给目标属性赋值会反映在两个对象上，因为两个对象访问的是同一个值
target.id = &quot;foo&quot;;
console.log(target.id); // foo
console.log(proxy.id); // foo

// 给代理属性赋值会反映在两个对象上，因为这个赋值会转移到目标对象上
proxy.id = &quot;bar&quot;;
console.log(target.id); // bar
console.log(proxy.id); // bar

// hasOwnProperty() 方法在两个地方都会应用到目标对象
console.log(target.hasOwnProperty(&quot;id&quot;)); // true
console.log(proxy.hasOwnProperty(&quot;id&quot;)); // true

// Proxy.prototype 是 undefined，因此不能使用 instanceof 操作符
console.log(target instanceof Proxy); // TypeError: Function has non-object prototype 9 &#39;undefined&#39; in instanceof check
console.log(proxy instanceof Proxy); // TypeError: Function has non-object prototype 9 &#39;undefined&#39; in instanceof check

// 严格相等可以用来区分代理和目标
console.log(target === proxy); // false</code></pre>
</div>
<div id="定义捕获器" class="section level3">
<h3>1.2 定义捕获器</h3>
</div>
<div id="捕获器参数和反射-api" class="section level3">
<h3>1.3 捕获器参数和反射 API</h3>
</div>
<div id="捕获器不变式" class="section level3">
<h3>1.4 捕获器不变式</h3>
</div>
<div id="可撤销代理" class="section level3">
<h3>1.5 可撤销代理</h3>
</div>
<div id="实用反射-api" class="section level3">
<h3>1.6 实用反射 API</h3>
</div>
<div id="代理另一个代理" class="section level3">
<h3>1.7 代理另一个代理</h3>
</div>
<div id="代理的问题与不足" class="section level3">
<h3>1.8 代理的问题与不足</h3>
</div>
</div>
<div id="代理捕获器与反射方法" class="section level2">
<h2>2.代理捕获器与反射方法</h2>
</div>
<div id="代理模式" class="section level2">
<h2>3.代理模式</h2>
</div>
</div>
